=================================================
Current perf (spring optimization + double spring iterations)
=================================================
- fps: 30.8 (Samsung: 20.3 (Krafting)) (Mattia's: 15.5 (Krafting))
- World::Update: 57.05%
	- Ship::Update: 56.89%
		- UpdateMechanicalDynamics: 47.56%
			- UpdateSpringForces: 37.08%
			- UpdatePointForces: 5.30%
			- HandleCollisionsWithSeafFloor: 2.92%
			- IntegrateAndResetPointForces: 2.26%
		- UpdateWaterDynamics: 7.83%
			- UpdateWaterVelocities: 7.72%
- World::Render: 28.15%
	- RenderContext::RenderCloudsEnd: 3.98%

=================================================
Past perf (ephemeral particles)
=================================================
- fps: 28.8/29.0 (Samsung: TBD (Krafting)) (Mattia's: TBD (Krafting))
=================================================

=================================================
1.6.0 perf
=================================================
- fps: 29.6 (Samsung: TBD:31.5 (Krafting)) (Mattia's: TBD:25.1 (Krafting))
- GameController::Update: 35.06%
	- Ship::Update: 34.33%
		- UpdateMechanicalDynamics: 25.70%
			- UpdateSpringForces: 18.80%
			- UpdatePointForces: 3.45%
			- HandleCollisionsWithSeafloor: 2.45%
			- IntegratePointForces: 1.00%
		- UpdateWaterDynamics: 7.83%
			- UpdateWaterVelocities: 7.73%
			- UpdateWaterInflow: 0.05%
		- UpdateStrains: 0.78%
	- DiffuseLight: 0.58%
	- WaterSurface::Update: 0.11%
- World::Render: 57.00%
	- ShipRenderContext::RenderEnd: 52.87%
	- RenderContext::RenderCloudsEnd: 1.49%
	- RenderContext::RenderStart: 0.50%
	- Ship::Render: 0.14%
		- UploadPoints: 0.12%
	- RenderContext::RenderWater: 0.05%
	- World::RenderClouds: 0.04%
		- fmodf: 0.02%
	- RenderContext::RenderLand: 0.01%
- RenderContext::RenderEnd: 0.35%
	- TextRenderContext::RenderEnd: 0.35%
- wxGLCanvas::SwapBuffers: 1.07%
=================================================
NoInline
- World::Render: 53.36%
	- ShipRenderContext::RenderEnd: 49.69%
		- ig4: 49.22%
		- RenderRopes: 0.43%
		- ...
	- RenderContext::RenderCloudsEnd: 1.37%
	- RenderContext::RenderStart: 0.46%
	- RenderContext::RenderWater: 0.04%
	- World::RenderClouds: 0.02%
		- fmodf: 0.01%
	- Ship::Render (with uploads): 0.15%
	- RenderContext::RenderLand: 0.01%
	- RenderContext::UploadLandAndWaterEnd: 0.04%
	- RenderContext::UploadLandAndWater: 0.03%
- RenderContext::RenderEnd: 0.30%
=================================================
Render:
	- No Ship::RenderEnd: 64fps
	- Only springs: 30fps
	- Only triangles: 42fps
=================================================
1.3.0 perf
=================================================
- fps: 27.3 (Samsung: TODO (Krafting)) (Mattia's: TODO (Krafting))
- GameController::DoStep: 33.06%
	- Ship::Update: 32.07%
		- UpdateDynamics: 25.53%
			- UpdateSpringForces: 18.72%
			- UpdatePointForces: 3.55%
			- HandleCollisionsWithSeafloor: 2.27%
			- Integrate: 0.98%
		- GravitateWater: 4.60%
		- BalancePressure: 1.06%
		- UpdateStrains: 0.83%
		- LeakWater: 0.03%
	- DiffuseLight: 0.89%
	- WaterSurface::Update: 0.09%
		- sinf: 0.07%
- MainFrame::RenderGame: 60.47%
	- ShipRenderContext::Render: 53.52% (Incl) 0.00% (Excl)
		- ShipRenderContext::RenderSprings: 30.72%
		- ShipRenderContext::RenderTriangles: 22.29%
		- ShipRenderContext::RenderRopes: 0.45%
		- Points::Upload: 0.14%
	- RenderContext::RenderCloudsEnd: 2.87%

====================================================
====================================================
====================== Plan ========================
====================================================
====================================================

- Marketing:
	- Video of Titanic under Mariannes' Trench
		+ After water contrast

- Roadmap:
	- 1.8.0
		- Fix starting folder for ships
		- Libsimdpp spring relaxation (*)
		- Batisphere with pumps and propulsion (*)
			- Multi-layer ship definition files (*)
			- Switches (*)
			- Pumps (*)
			- Propulsion (*)
			- Batisphere
		- Bubbles (*)
		- Smoke (*)
	- 1.9.0
		- Flood tool (*)
		- Z Buffer (*)
		- Settings Manager (*)
	- 1.10.0
		- Frontier
		- Resource Packs (Moleskine)

- New ships
	- Roma
	- Fix contributions
		- PacMaster
	= USS Shark
		- Need Z buffer work first
	- Warship
	- See Moleskine

- Suggestions to spec:
	- Different colored lights
	- Lights with different chances of turning off
		- Do they need longer-living lights?
	- Custom sky colour - if possible a RGB picker in the settings
	- Black hole

- Technical debt

- Simulation Optimizations:

	+ BufferAllocator<Type:vec2f or float>
		+ cctor takes ElementCount
		+ Allocate() returns std::unique_ptr<Buffer<Type>>, with deleter invoking mAllocator->Release(Buffer<type>*)
		+ Points::CheckoutWaterBufferTmp (as "AllocateWaterBufferCopy()") borrows one, copies it in, and returns it as std::unique_ptr<Buffer<float>>
		+ Opposite for Commit() (as "UpdateWaterBuffer")

	= Do SSE with libsimdpp:
		- First check out alternative: https://xsimd.readthedocs.io/en/latest/
		- Prepare sources:
			- GameLib/LibSimdPp.h
				- Defines macro for SSE3 and includes simd.h
					- So that we have a single place for the macro
				- Then defines VECTORIZATION_FLOAT32_SIZE as SIMDPP_FAST_FLOAT32_SIZE, and VECTORIZATION_INT32_SIZE as ...INT32...
					- Allowing us to change it in one place to experiment with loop unrolling
				- SSE code will use VECTORIZATION_FLOAT32_SIZE as the batch size, via SysSpecifics.h (see below)

				- #define SIMDPP_NO_DISPATCHER
				- CMake:
					- register_external(libsimdpp x_libsimdpp) à libsimdpp_path = /../../../ x_libsimdpp
					= target_include_directories(common_models_lib SYSTEM PUBLIC ${libsimdpp_path})
			- Merge FloatingPoint.h into SysSpecifics.h and nuke FloatingPoint.h
			- SysSpecifics.h:
				- Includes LibSimdPp.h
				- make_aligned_element_count: local static constexpr for word size, choosing max of VECTORIZATION_FLOAT32_SIZE & VECTORIZATION_INT32_SIZE

		= UpdateSpringForces:
			+ Version 0/Optimization 1:
				UpdateSpringForces_Naive_mean                     566158909 ns  553803550 ns          1
				UpdateSpringForces_Naive_median                   564963849 ns  561603600 ns          1
				UpdateSpringForces_Naive_stddev                     4619531 ns   18596554 ns          1
				-
				UpdateSpringForces_LibSimdPpAndIntrinsics_mean    431502311 ns  409502625 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_median  415921334 ns  409502625 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_stddev   35247735 ns   18160977 ns          2
			+ Optimization 2 (SpringDir less divisions):
				UpdateSpringForces_LibSimdPpAndIntrinsics_mean    419323870 ns  408332618 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_median  418272468 ns  405602600 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_stddev    6254057 ns    7279802 ns          2
			+ First NaN avoidance:
				UpdateSpringForces_LibSimdPpAndIntrinsics_mean    424542593 ns  402872582 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_median  412086262 ns  401702575 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_stddev   39465568 ns   11672674 ns          2
					and
				UpdateSpringForces_LibSimdPpAndIntrinsics_mean    416146077 ns  398192553 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_median  410967797 ns  397802550 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_stddev    9809876 ns    9628195 ns          2
			- Try rearranging instructions for cache

		- Use at IntegratePointDynamics, to guarantee SSE2
			- Verify with asm
			- Add to credits

		- Use at Ship::MoveBy(), to guarantee SSE2
			- Verify with asm
			- Add to credits

		+ Avoiding if's for divisor==0
			+ No 0.0 checks for divisions, but + 0.00001
				+ Verify behavior of float::max/float::min
				+ Do benchmark: worse
				+ Conclusion: should be used only for SSE vectorization, and when dividend has same
				  magnitude as divisor (e.g. for normalized vector, len==0 <-> x==0 && y==0)
			+ Should investigate masking at the same time, might be faster
		+ Try with different cache optimization heuristics
			+ Starting point: Spring ACMR: original=0.516807, optimized=0.325156
			+ Choose springs with largest numbers of points in cache

	- UpdateWaterDynamics:
		- Test turning it around into (multiple) spring visits, rather than point visits
			- Multiple because of need to normalize outgoing for each point

	- See if can avoid other IsDeleted checks, via zero'ing of coefficients

	- UpdatePointForces:
		- Substitute "if(y<waterHeight)" branches with "float isUnderwater (1.f/0.f)"
			- Force compiler into not branching - "?" operator won't work
		- Precalculate things that do not depend on position nor velocity
			- Stored in buffers
				- When possible, via template/lambda tricks
			- Technically, would have to store separately effectiveMassMultiplier (*Mass) and effectiveBuoyancy (*Mass)
				- Test: but could cheat and use water height based on initial positions only, in which case
				  we store directly the result as FieldForce == Gravity + Buoyancy + Water Drag
				  - FieldForce used directly in Integrate(), added to Force (-> "SpringForce")
				  - This allows us to call UpdatePointForces only once
				  - Also need to reset StaticForce buffer before UpdatePointForces, so:
					- UpdatePointForces becomes CalculateFieldForces and take care of *filling* the buffer, overwriting it
	+ Water and Land interpolations:
		+ Prepare first test bench (noinline)
			+ GetWaterHeight: 2.23%
			+ GetFloorHeight: 1.66%
			+ Save assembly
		+ 1: see if it's better to store delta's and/or other pre-calculated things
		+ 2: see if can do semi-integer x-axis interpolation
			+ GetWaterHeight: 1.25%
			+ GetFloorHeight: 0.77%
		+ Cleanup test bench
		+ Final functional test
		+ Final FPS test

	- Cache sea depth from PointDynamics at first calculation (Points?), using lambda

- Gfx optimizations:

	- See if can unify springs and ropes rendering
		- Just make sure that ropecolor is already in point color buffer
		- RenderSprings + RenderRopes == new RenderSprings:
			- Watch out: ropes can't ever use texture
		- What about rendering phases?

	- Try using GL_SHORT for Ship texture coordinates
		- Passing NORMALIZE and 3 components to glVertexAttribPointer

	+ (Retry) Use CPU and GPU in parallel
		+ Finalize render (glFlush) before render step, not after
			+ Research glFlush()
			+ By invoking glFlush() and SwapBuffers() in MainFrame, before Render()

	- More connected components => slower (multiple batches); try
	  to draw one single batch then, using Z buffer and depth test 
		- Assign Z based on connected component ID
		- Plan:
			- TODO: review the below based off transparency sorting - see MOLESKINE
			1 - Test perspective with hardcoded z=-800 at shader, and see if it makes any difference
			2 - Ship assigns points' ConnectedComponentID as float in vector
			3 - ShipRenderContext's shaders (Triangles, Springs) take Z and with ad-hoc OrthoMatrix
			    transform ConnectedComponentID to Z
			4 - ShipRenderContext::UploadXYZElement() does not take anymore connected component ID
			5 - (Nice to have): sticky component IDs, by leveraging the fact that normally IDs are assigned from L,T to R,B
		- See if drawing springs & triangles at separate depths also helps generally with render speed, even for one single
		  connected component (for springs' fragment shader - may be it takes shortcuts if it knows it's behind)
		- After Z is done:
			- GenericTextureShader also takes ShipID, ConnectedComponentID for Z, and exists in one central place
				- Invoke shader at one place (still for 1 texture at a time, waiting for atlas)
					- Move this shader and all ShipRenderContext::UploadTextureRenderSpecification to 
					  RenderContext
					  - With optional <ship ID, connected component ID> pair (not set -> main UI, on top of everything)

- Gfx:
	- A toggle-able shader for the sea - so it gets darker the further down you go; it would be affected by the ambient lighting
		- Need new scalar vertex attrib for depthBrightness - between 1.0 (top) and 0.0 (at greater of 1000m and sea depth)
			- depthBrightness is always 1.0 if "modulate sea depth brightness" (new boolean GameParam) is not set

	- Problem with texture over edges of structure: when texture is not reduced by structure (i.e. when structure is
	  larger than texture), then one sees parts of the springs
		- It's a problem with rendering springs with the texture shader
		- However, these springs give an anti-aliasing effect
	- Draw better (depth-wise) those parts that are only connected by ropes 
		- Change connected component detection by not propagating from a "spring only" to a "body", so that two bodies connected
		  only by springs or ropes are considered separate, and spring/rope belongs to first one only
			- In practice: flood the *edge* network, not the spring network, and don't propagate
			  if coming from edge with zero triangles to an edge with !=0 triangles
	- Option to enable drawing of force vectors for each point
		- Ship::Update() takes also RenderContext const &, so can check if need to save force buffer
			- Points::SaveForceBufferForVectorRender()
		- Copied right before integration
	- AmbientLightIntensity:
		+ Use also in RenderContext::RenderStart() for clear (sky) color
		+ Phase 1: pgup/down
		- Phase 2: with clock / time-of-day
			- Sky should also have crepuscolar gradient
	- Magnifying glass
		- https://www.opengl.org/discussion_boards/showthread.php/154811-magnifying-glass-effect
		- https://www.shadertoy.com/view/4tdXDl
	+ Bug: bombs et al fade more rapidly than ship when ambient light goes away
	+ Stars at night
		+ Render:
			+ Need to be done at clouds, w/water stencil
		+ Physics::Stars
			+ Update(GameParams) -- recalcs if # changed
			+ Upload(RenderContext)
			+ Managed by world
		+ Test ambient light -> transparency curve
		+ Test customizability
		+ Compare with screenshot
		+ Check performance
			+ FPS: 28.4
			+ PerfAnalysis

- Dynamics:

	- OceanFloor:
		- Make number of samples be bump map width
		- Still check width is power of two
		- Still calculate bit stuff for fast mod

	- Ocean floor breaking up upon impact
		- Layer on top of floor samples, with hash buckets and lists of heights per-bucket
		- Spec:
			- Ocean floor has "height overrides" for bumps, etc.
				- Addressed via "quantized X", i.e. buckets of X
					- BucketSize ~= "default/initial visible world width" divided by ~ number of slices (512)
						- Or dictated by will to re-use sample index @ sampling
				- Fast lookup of X:
					- Hash table w/hash=periodic bucketized X (same used for curve interpolation),
					  & value=list of actual "quantized X" with corresponding H
					- Hash table is array<vector<x, h>, # of buckets>
			- @ Ocean floor collision:
				- Upon point entering floor:
					- Points goes back by displacement * FloorHardness
					- Ocean floor's H goes back by displacement * (1 - FloorHardness)


	- Auto-adjust zoom at ship load
		- Use preferred zoom from .shp file
		- Configured by GameController

	- Slider for "Mass Adjustment"
		- Recalcs Point's mass things, including mass itself
		- Also used at bombs for bombs' mass - how?
		- When done, re-enable buoyancy fix
		- TODO: really worth doing? If water mass is also adjusted, then nothing really changes


	- Figure out what to do with connected components and ephemeral particles
		- Depending on the above:
			- See if can piggyback the fact that Points is already uploading all (well, now non-ephemeral) point element indices
			- ShipRenderContext: for each conn component, use a vector (w/reserve) rather than full MaxParticles
				- Can then get rid of MaxCount, CurrentCount
		- Possible solution # 1: wait for Z buffer; when it will be done everything will be for free:
			- Assign provoking point's Connected Component ID 
			- ConnectedComponent buffer is a proxy of points' Z, has no bearing to multiple buffers that need to be pre-allocated
			- Ephemeral particles in ShipRenderContext are then a single NOT-per-connected-component single buffer of indices,
			  exactly like normal points
				- May be at this moment we can unify normal point uploading

	- Ephemeral particle emitters
		- Implemented like electrical elements, i.e.:
			- EphemeralParticlesEmitters container, almost clone of ElectricalElements
				- Contains point index and IEphemeralParticleEmitter
					- IEphemeralParticleEmitter: 
						- void Update(clockNow, Points &, MaterialDatabase const &)
						- Impl knows its point index
				- Passed already populated by ship builder
		- Ship has EphemeralParticlesEmitters, passed already populated by ship builder
			- Registers DestroyHandler, all identical to ElectricalElements
		- Ship::UpdateEphemeralParticles: invokes EphemeralParticlesEmitters::Update(...)
			- Which invokes IEphemeralParticleEmitter::Update(clockNow, mPoints) for each emitter

	- Research particle motion - inject random walk in smoke and bubbles
		- https://core.ac.uk/download/pdf/337937.pdf !!!
		- http://orbit.dtu.dk/files/3706687/Visser6.pdf
		- @ Smoke
			- http://matthias-mueller-fischer.ch/publications/sca03.pdf
		- @ Air bubbles
		
	- Smoke:
		- New material: smoke emitter
			- Recognized by ship builder via "particle_emitter_properties" sub-object
		- New material: smoke
			- Lighter than air
		- UpdatePointForces: if any point is above water, apply air buoyancy
			- i.e. always end up applying one buoyancy, either water or air
		- IEphemeralParticleEmitter implementation: SmokeEphemeralParticleEmitter


	- Switches:
		- New electrical material type; color trick like ropes to have unique and deterministic IDs for switches
			- One material (base structural color) for initially on and another one for initially off
			- New electrical property: ConductsElectricity, bool - used at connectivity visit
		+ ObjectId overhaul:
			+ ObjectId is unique only in the context in which it's used (e.g. bombs vs switches)
			+ ObjectId == <ShipId (new GameType alias, uint32_t w/ None), LocalObjectId (uint32_t)>
				+ LocalObjectId is provided by caller
				+ ObjectIdGenerator only provides helper for globally unique - with no guarantees - or should go
			+ All ship ID ints become ShipId
			+ All object ID ints become ObjectId
		- Ship json adds optional names for each ID
			- as vector<tuple<local switch ID, std::string>>>
				- local switch ID is ID from color code
		- ShipBuilder detects all switches as electrical elements
			- Generates an ObjectId using ship ID and index of switch
			- Each switch gets own ObjectId, as part of Electrical Elements data communicated to ship
				- LocalObjectId is just element index of switch in ElectricalElements
				- Also name goes into Electrical Elements
		- UI gets switches via AddSwitch (and DeleteSwitch) event, with all metadata (ID, name, state)
			- From Ship::cctor, visiting switches among ElectricalElements
			- SwitchBoard panel
				- Registers as event listener at cctor
				- Uses GameController (own shared ptr) :: SetSwitch(ObjectId switchId, bool state) to control switches
		- MainFrame also registers for AddSwitch and shows SwitchBoard on first add
			- Hides it again only at Reset()
		- Ship must invoke DeleteSwitch at switch deletion (@ Ship::ElectricalElementDestroyHandler)
		- Electrical dynamics:
			- ElectricalElement: rename "ConnectivityVisit" (sequence number, etc.) as "ElectricalPropagationVisit" (...)
				- Ship::UpdateElectrical"Propagation"
			- ElectricalElement has new "conductsElectricity" bool buffer
				- Init'd with material's
				- Ship::UpdateElectricalConnectivity checks conductance first when deciding to follow a connected electrical element
			- Ship::SetSwitch(switchId, bool):
				- Toggles electrical element's "doesConductElectricity", via ElectricalElements::SetSwitch(switchId, bool)
	- Pumps
		- Spec:
			- New electrical element
			- Two types: "in" or "out" (a bool electrical property)
			- Water is taken @ ElectricalElements::Update()
			- Point that pump is attached to may or may not be hull, and may or may not be leaking; regardless, when powered,
			  water is sucked in our out
			- Continuous sound when pumping
		- Impl:
			- ElectricalElements::Update():
				- For each pump element (own separate list, for perf):
					- If powered: // eventually have state machine for lead-in/lead-out
						- If type is "in" && y < waterLevel && point.water < external pressure:
							- Take in water - with quantity from GameParameters
						- Else if type is "out" && point.water > 0:
							- Take out water - same quantity from GameParameters
			- @ power state changes: emit event, for continuous sound - much like TimerBomb's fuse
				- Need object ID

	- Flood doors
		- Spec:		
			- New electrical element
			- Point that flood door is attached to may or may not be leaking
			- Plays one-shot sound @ when open or closed - much like TimerBomb's defuse
				+ No ObjectID needed thus
			- Power connectivity state changes cause modifications of water propagation coefficient of spring (i.e. WaterPermeability)
		- Impl:
			- ElectricalElements::Update():
				- For each flood door element (own separate list, for perf):
					- Run state machine (including eventual lead-in/lead-out's)
					- @ state changes:
						- For all connected springs: one of the following, depending on connectivity state:
							- Springs::SetWaterPermeability(idx, val) 
								- See if can use fractional values for half-open/half-closed
							- Springs::SetDefaultWaterPermeability(idx)
								- Uses private CalculateWaterPermeability(), also used by cctor
						- Anything else? See water momenta algo
			+ No real need to also change Point::Buoyancy
			+ No real need to also change Point::IsHull
				+ Points' hullness is only used to decide whether or not to make a point Leak when an attached spring breaks; we
				  leave this determined by underlying structural material
			+ Springs::IsHull should be gone by now



	- Propulsion
		- New electrical element
		- Electrical current controls force
		- At ElectricalElements::Update(): if powered, apply force to point (4 materials for 4 directions)

	- Test:
		- Self-adjustment of kSpring and kDamp based off paper's formula (H and L bounds)
		- Debug to see if bounds ever exceeded

	- Frontier:
		- Only for non-rope points - rope points never take part in frontier
		- Preliminaries:
			- Make sure endpoints in triangle are always in CW order
			- In order to correctly draw dangling (i.e. same connected component) parts on top of all of the connected component's 
			  frontiers, we'd need to have the dangling parts disconnected from the connected component, which means that we should
			  not follow ropes during connected component detection
				- Still vulnerable to dangling parts not connected via ropes (e.g. masts) though: frontier would be drawn on top of it
				- Might get away with drawing frontiers - *enlarged* - before all of the rest? The enlarged part would be visible
				  only through holes and around external frontiers
		
		- TODO: all the following might have to be revisited
		- Realize that a node can belong to up to 4 frontiers (center of 4 holes)
			- And a point deletion might cause a merge of the four
		- Frontier is set of points, marked as frontier, and connected to each other via 
		  nextInFrontier * and prevInFrontier * (in CW order) 
		- Algo:
			- There are multiple frontiers, 0 is external, N is internal, isolated
			- Calculate frontier at ship create, based off structural matrix, using geometry
			- At each point deletion:
				- 2 cases: OR: only later check if one of the connected points is already a frontier 
				  (a deleted frontier point is bound to be connected to two other points of the same frontier, for each frontier)
					- Point deleted is a frontier point:
						- TODO
					- Point deleted is NOT a frontier point:
						- All its connected points become a frontier
						- If one of the connected points is already a frontier, then the new frontier points
						  take that frontierId
						- TODO
	- Water drag 
		- The one already there assumes velocity always normal to surface, but we should consider surface normal instead

	+ Move tool
		+ Rename current "move" as "Pan"
		+ ShipId type (see around here)
		+ ObjectId type (see around here)
		+ With move tool enabled:
			+ Click on ship -> GameController returns std::optional<ShipId> -> if not None, tool is engaged (save cur screen pos)
				+ Works like pan 
			+ Moving tool tells GameController delta (offset) screen 

	- DestroyAt:
		- Test: Ship::SpringDestroyHandler() only destroys triangles that contain A-B
			- Should definitely make both A and B leak, as they both now have an adjacent hole
	
	- See if can use external water's pressure to inflict stress on springs
		- Have to visit frontier points and, if underwater, do force perpendicular towards interior

	- Stars with database
		- python script to generate binary maps for N and S emispheres

	- Random noise that lowers strength to inject "cracks" when the ship is under stress
		- Random walk across pairs of points on opposide sides of ships

	- Friction on ocean floor, adjustable

- Water:
	-Do water bubbles (at intake) and water drops (at outtake)
		- Ephemeral particles emitted at UpdateWaterIntake()
			- Intake:
				- Material ("Air") with zero weight so rises up automagically
					- Hardcoded material added by MaterialDB from in-code list
			- Outtake:
				- Only emit if Y above water line
				- Material is water
					- Hardcoded material added by MaterialDB from in-code list
	- OLD: Optimizations:
		- GravitateWater:
			- Calculate once and for all cos theta's at first iteration
				- !!! Actually, calculate WaterGravityFactorA = dt*0.6*(1+cos_theta)/2, WaterGravityFactorB = -dt*0.6*(1-cos_theta)/2
					float cos_theta_select = (1.0f + cos_theta) / 2.0f;
			                float correction = 0.60f * cos_theta_select * pointA->GetWater() - 0.60f * (1.0f - cos_theta_select) * pointB->GetWater();
			                correction *= GameParameters::SimulationStepTimeDuration<float>;
				- Test (check disassembly) with templated lambda (Spring const &)->void
					- First one calculates factors and stores them in Spring
					- All others empty
					- All iters take factors from Spring after calling lambda


	- Sinking detection is broken - it currently only considers total water that entered the ship, which comes proportionally to external
	  water pressure; all this water could be confined to a tiny volume, and yet we trigger sinking
		- Solution: make it based on total number of points that have water instead, i.e. wet points
			- ...which requires 
			- Option1: or can just be calculated at end of each update with simple pass through water buffer and previous water buffer
				- Better, "if" for prev_value==0 would be done only once per Ship::Update()
				- Costly to copy water buffer
			- Option 2: 
				- Points keep track of point's water going from 0.0 to > 0.0, at all possible
				  avenues of change (LeakWater, BalancePressure, etc.)
					- Need Points::mIsWetBuffer and mWetPointsCount, both set/incrd automagically when Points::AddWater is called
				- Needs multiple ifs - one at each change - vs. a single if at Option1
	+ Did original game propagate water also through hull springs? YES. How did hull thin dividers work? THEY DIDN'T WORK
	+ Add Point::Hull Characteristic, and don't leak/propagate(incl. gravitate) water if at least one of the two points is hull			
		+ Alternatively: just make a spring hull if one point is hull; test it
	- Make waves with Shallow Water Equations 
		- And if frontier works, change height when frontier touches water for the first time
		- Problem with extent of heightfield (X segment): needs to look good when zooming out; 3 alternatives:
			- 1: Find a way to stitch X segment to required world X
				- Note that can't mirror segments or else waves would have different directions
			- 2: Upsample and downsample depending on zoom
				- But we lose details when we zoom out and then in again
			- 3: Just cap zoom to reasonable max
	- Breaking waves (Muller's paper)


- Controls:

	- Tool to flood ship
		- Name: Flood
		- Icon: bottle
		- New ToolController/Tool
			- Continuous, like Destroy
		- World->Ship::OnFloodAt(x,y,strength)
			- Find closest (very small radius)
			- Add water quantity to point
			- Emit event
		- Sound: continuous as long as ship takes water
			- So, like sawed
				- Update() attempts to stop it
				
	- Changing the width of the waves up to at least 10x the current size
		- Requires re-calculation of period (if adjustment is x-multiplier N, then period is N times basic period)
		- Resolution stays the same

	- Allow ocean floor bump map to be loaded at runtime
	
	- Ship definition: multiple layers
		- We want to maintain BW compat for ease of one-layer ship making
		- TODOHERE: see Moleskine
		- JSON: "extra_layers: ["rms_titanic_whatever.png.dat", ...]
		- Material: becomes collection of N pointers: Structural (or "physical") (includes Sound), Electrical, Emitter, etc.
		- ShipBuilder:
			- Each extra layer provides to corresponding point in structural layer only electrical, emitting, etc. attributes
				- PointInfo has separate Material::Physical/Electrical/EtcCharacteristics
				- Points::Add takes additional Material::Electrical/EtcCharacteristics *'s, these are
				  the ones used (if present) instead of plain material's
			- Error if a non-zero layer provides:
				- 1) data for point non-existing in zero layer
				- 2) data that already exists (e.g. ElectricalChar's)

	- Ship definition: "instructions"
		- If present, at the first load of a ship spawns a text box (if enabled in settings)

	+ Control incisiveness (contrast) of water color for water in ship
		+ New uniform

- UI:
	+ SettingsDialog: tooltips at Simulation Quality (tradeoff) and Stiffness (instability)
		+ Use "Attention" icon
		+ wxToolTip
		+ SQ: Higher values improve the rigidity of simulated structures, at the expense of longer computation times
		+ S:  Higher values cause physical instability but provide for a nice effect!
		+ See if global settings are really needed
			

	- TODOHERE: SettingsDialog: save settings, and defaults
		- SettingsManager (@FloatingSandbox):
			- Has GameController, SoundController, etc.
			- Defines struct with all customizable setting members
			- Maintains two copies of struct:
				- Defaults
				- Current (ephemeral)
			- Manages saving and loading customizable settings to and from json
			- Created by MainFrame on startup
			- Exposes getters and setters for all customizable properties, used by SettingsDialog
				- get(): from Current
				- set(): sets Current
			- cctor (actually, CreateInstance()->uq_ptr which MainFrame makes shared):
				- Stores defaults (in Defaults), asking members for their (compile-time default) values
				- Then copies Defaults to Current
				- Then loads personal_settings.json, if exists; if exists:
					- Reads settings to Current
					- Then applies settings - invokes SyncToGame()
			- SyncFromGame()
				- Reads Current from GameController, SoundController, etc.
			- SyncToGame()
				- Applies Current to GameController, SoundController, etc.
			- Load(filepath)
				- Loads from path - sets Current
				- Does not apply
			- Save()
				- Saves Current to personal_settings.json 
			- Save(filepath)
				- Saves Current to filepath
			- Reset()
				- Copies Defaults to Current
				- Does not apply
		- Impl:
			- Standard paths: http://docs.wxwidgets.org/3.1/classwx_standard_paths.html#a4752213ef4d7bdc71170b9e5c3691f0f
				- MainApp: call App::SetAppName() at startup
					- With app name from version.h
				- SettingsManager can deal directly with wxWidgets
		- Dialog:
			- Control values are meant to always be in sync with SettingsManager::Current;
			  however, for simplicity we only sync between the two when needed
			- OnShow():
				- Calls SettingsManager::SyncFromGame() (Current)
				- Reads all control values from SettingsManager
				- Does not mark as dirty
			- Apply: applies settings
				- Writes all control values to SettingsManager (Current)
				- Calls SettingsManager::SyncToGame()
				- Clears dirty
			- Save Settings: saves current to personal_settings.json
				- Writes all control values to SettingsManager (Current)
				- Calls SettingsManager::Save()
				- Stays dirty if it was dirty
			- Save Settings As: saves with filename
				- Writes all control values to SettingsManager (Current)
				- Calls SettingsManager::Save(filepath)
				- Stays dirty if it was dirty
			- Load Settings: loads with filename, changes own settings
				- Calls SettingsManager::Load(filepath) (Current)
				- No apply
				- Reads all control values from SettingsManager
				- Marks self as dirty
			- Reset Settings: 
				- Calls SettingsManager::Reset() (Current)
				- No apply
				- Reads all control values from SettingsManager
				- Marks self as dirty

	- Revised FileDialog for loading ships: shows previews of ships
		- Option 1: see if possible to hook into basic FileDialog's rendering of files
		- Option 2: custom FileDialog ("ShipFileDialog"), with directory tree on the left and preview in main area
			- Show also name, dimensions, and total mass

	- Save screenshots/photos 
		- Saves automatically in custom folder
		- Code (at RenderContext::TakeScreenshot() -> returns ImageData)
		    glPixelStorei(GL_PACK_ALIGNMENT, 1);
		    glReadBuffer(GL_FRONT);
		    glReadPixels(0, 0, windowWidth, windowHeight, GL_BGR_EXT, GL_UNSIGNED_BYTE, pixels);

- Sounds:
	- Ship may come with custom sound(s) for horns
		- Figure out how to play them, may be like switchboard or *via* switchboard, or with just one horn sound
	- Morse code sound when it's about to sink (early sink detection)
		- Or at first drop of water
		- Morse code: text-to-morse encoder would be cool
			- Default "S.O.S.", also customizable via ship property
	- Volume of effects should depend on distance/zoom

-Probing:
	- IProbe:
		- World and Ship take shared_ptr<IProbe> and store it, exactly like IGameEventHandler
		- Single instance of IProbe is ProbePanel, which is given to GameController::cctor by Frame at initialization
		- Example IProbe methods:
			- void ProbeWaterSplashed(float waterSplashed)
				- One scalar, pass through to ScalarTimeSeriesProbeControl (iff IsActive)
			- void ProbePointForces(vec2f const *)
				- For other things at different steps in the simulation algorithm
				- IProbe knows whether it cares about a specific point and, if so, takes that and draw is
				- IProbe might also create stats
	= ProbePanel
		- Pre-created member of MainFrame
		+ Then exposes Update() invoked by MainFrame, always, after simulation step
		+ Update(): 
			+ if not visible, return;
			+ Draw current Statistics from current StatisticsProbe
		- TBD: mechanism to select point, etc. from ship, which will be used for probing afterwards
	- Histograms:
		- class Histogram
			- map<float, float in [0,1]>
		- class Statistics (various Histograms, etc.)
			- Histogram pointWaterHistogram
			- ...

- Multiple ships:
	- Better done after collision detection
	- When ship loaded (added):
		- World adds it not to mShips, but as opt<Ship> mPendingShip
			- Not considered in Update(), but considered in Render()
		- MainFrame begins new PendingShipPlace tool
			- OnMouseMove: tell GameController (->World) mouse position as GameController::MovePendingShipTo(screen coords)
				- Ship::MoveTo(world x, y): 
					- Moves all Points by (x,y)-mCurrentRepresentativePosition
						- Ship::mCurrentRepresentativePosition (init'd as {0,0}) tracks current "center"
					- mCurrentRepresentativePosition = (x,y)
			- OnLDown:
				- Tell GameController (DropPendingShip(x, y)) which:
					- Tells World via World::DropPendingShip(x, y):
						- Final Ship::MoveTo()
						- Move ship from mPendingShip into mShips
					- Fires IGameEventHandler::OnPendingShipPlaced(shipId)
						- EventTicker: say this and other Reset/Load
						- SoundController: play sound
				- Stop PendingShipPlace tool

- Passengers:
	- Separate layer provides floors, ladders, and obstacles
	- Ship has number of passengers
	- Can get away at beginning with pacman-like figures
	- For more realistic version:
		- Skeleton with 10 parts (8 limbs, body, head)
		- Need to make these actions:
			- Walk
			- Fall
			- Climb
			- Swim

- Collision detection - for multiple ships
	- Nearest neighbor: http://www.cs.umd.edu/~mount/ANN/

==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==== DONE
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================

+ Build glfw yourself
	+ clone from git
	+ build
	+ fix Ship's CMake
		+ C:\Users\Neurodancer\source\build\glfw\src\Release
+ move to source/build:
	+ ShipSandbox

IF WX:
+ build WX (Debug, Release)
+ add WX to CMakeFiles.txt
	C:\Users\Neurodancer\source\repos\wxWidgets\include
	C:\Users\Neurodancer\source\repos\wxWidgets\lib\vc_x64_lib
		names: wxmsw31u[d]_core.lib wxbase31u[d].lib
+ remove titanicapp.*, titanicmain.* from CMakeFiles.txt
+ do a simple main with wx
+ rebuild WX with C++ Runtime being statically linked
+ test
+ see getting rid of whole wx.h and only include wxwindow
+ get rid of GLFW in all source files
+ setup CMakeFiles.txt: Remove GLFW
+ resuscitate old code, merging it with new existing structure:
	+ mainApp - mainApp class, main #define
	+ mainFrame - entire frame
+ test	
+ remove titanicapp.*, titanicmain.*, main_old.cpp
+ one-shot timer
+ nuke GLFW from hard disk (repo, build)
+ add logger and fix missing ship

+ Get perf baseline and start Readme.md and Changes.txt

===========
+ cherry-pick that typo fix
+ logging window: try http://docs.wxwidgets.org/3.0/classwx_text_ctrl.html
+ rename members of Frame, cleanup code

+ Render/Game"Settings" -> "Parameters"
+ LoggingWindow -> "Dialog"

+ SettingsDialog:
	+ Add spacing
	+ Taller sliders
	+ Min and Max
	+ add textboxes 4 vals
	+ ApplySettings()
		+ GameController takes (& gives) absolute vals, & provides GetXMax/MinValue() (from YYYParameters)
		+ Helper funcs in SettingsDialog do conversions
	+ ReadSettings()
	+ Other controls for other settings
	+ rename members, cleanup code

+ MainFrame:
	+ LogWindow bug when minimizing and maximizing main frame
	+ Do we need mMainGLCanvas and context to be unique_ptr's?
	+ Render once @ beginning
		+ Check if OnPaint is the right one
	+ Maximize
	+ ReloadLastSelected
	+ See if canvas.setcontext is necessary
		+ Watch out for resize
	+ +/- for zoom *IN MENU*
		+ remove wxEVT_CHAR_HOOK at panel and use menu hotkey and event instead

+ Investigate dirty lines

+ Use own exception

+ Fix DestroyAt
	+ Add DestroyRadius to GameParameters (not in SettingsDialog yet)

+ Fix final destroyer

+ Setup UnitTests
	+ Build GTest Debug and Release
	+ Create UnitTests project in CMake
	+ First unit test: vectors

+ GameException: cctor with string
	+ Utils::Convert(string)->wstring

+ Rebuild Devil but make it a dll with static runtime
+ Move DevIL init to GameController
	+ No DevIL dep's in ShipSandbox
	+ DevIL_INCLUDEs from GameLib are not public

+ Move to picojson
	+ Nuke SDK
	+ Remove public-ness of JSonCPP

+ Settings: 
	+ Destroy Radius
	+ "World"XYZ if really it is world

+ Frustum? For 2D? Try Ortho?

+ Change MainFrame's build info
	+ separate Version.h

+ Mask with copyright at all source files (copy from XXmain)
	+ Already capitalized
	+ Those to be capitalized
		+ material
			+ Rename
			+ cctors:
				+ from picojson obj
			+ Create()->UQ_PTR
				+ private cctor
				+ all members const
			+ optional Material::ElectricalProperties
		+ Also Renderer becomes a namespace, not a class
		+ render
			+ Renderer
			+ move ScreenToWorld here
			+ All static methods, inline
		+ util
		+ phys: 
			+ Rename as Ship, World, Point, etc.
			+ TODO: see first if can split into separate files
				+ commit & push first
				+ cpp's in namespace
				+ Physics.h: includes all and each .h and .cpp includes Physics.h 
			+ Private vs Public attributes:
				+ No friends
				+ All members mPrivate
				+ All getters and setters (when needed)
		+ vec

+ Simulation Optimizations:
	+ Move back to baseline
	+ Take profile X 2
	+ set these flags and see impact (on Release)
		+ Ox
		+ fp:fast
	+ Flags for non-MSVC:
				<Compiler>
					<Add option="-O3" />
					<Add option="-ffast-math" />
					<Add option="-fno-math-errno" />
					<Add option="-funsafe-math-optimizations" />
					<Add option="-ffinite-math-only" />
					<Add option="-fno-trapping-math" />
				</Compiler>
	+ Make all render() const
	+ Make all render() inline
	+ Make all vector funcs inline in .h
	+ Take full baseline first
	+ FPS: 17.3/17.7
	+ We don't need redundant triangles
		+ Row visit: for each point *after* the very first of a streak, only do triangles up to 90 degrees
			+ But keep doing all springs
			+ use boolean isInShip, init=false, set to true at end of single-point processing if point exists and set to false otherwise
		+ Before: 5231 points, 19932 springs, 19569 triangles
		+ After: 5231 points, 19932 springs, 9819 triangles
	+ FPS: 19.2/19.3
	+ Fix division by zero
		+ Do fix
	+ FPS: 19.1
	+ SSE2:
		+ Test first: Integrate: 
			+ 1a: pack Pos, Vel, Force from 2 points into local vec4f
				+ For loop with two points at a time
			+ 1b: create buffers with all Pos, Vel, Forces, and call function with restricted pointers: IT USES PACKED SSE's!
		+ Undo
	+ Vertex cache optimizations with Forsyth's algo:
		+ Break out ShipBuilder, friend
		+ Use own LRU cache and calculate current ACMR for triangles and springs
			+ Spring ACMR: 0.516807
			+ Triangle ACMR: 1.01986
		+ Do triangle vertex cache optimization
			+ New ACMR: 0.68174
			+ FPS improvement: 19.1 -> 19.0
			+ Check if self-covering within same connected component now looks weird
			+ Test on samsung: 18.5/18.8 -> 18.5/18.6/18.8/19.0
			+ REVERT, IT'S (MARGINALLY) WORSE!
		+ Do spring vertex cache optimization
			+ New ACMR: 0.325156
			+ New FPS: 19.4/19.7
	+ FPS: 19.3/19.5
	+ ShipRendering: upload triangles, ropes, springs only when they change
		+ Have VBOs per connected component
	+ FPS: 19.0/19.4/19.7/19.9
	+ Point & Spring Destructuring:
		+ Starting FPS: 19.0/19.4/19.7/19.9
		+ Main goal: improve cache locality
		+ Secondary goal: make vectorization-friendly
		+ Replace Point, Spring, Triangle with Points, Springs, Triangles
			+ Base is ElementContainer
				+ Defines aliases (ElementCount, ElementIndex) - uint32
				+ ElementCount GetCount() const
					- Number of elements
					- passed at cctor
			+ They contain N buffers:
				+ Points: Position, Velocity, Force, MassFactor, Color, Water, IsDeleted ...
					+ All scalars of a point that are only used for both x and y (e.g. MassFactor) are stored 
					 (and updated, if any) twice, as vec2f (only MassFactor?)
					+ All scalars of a point that are used as scalars (e.g. Buoyancy) are stored once
					+ Test first to see if N buffers make a difference vs 1 larger buffer: 
						+ 1: Do Position, Velocity, Force, and MassFactors first in single Newtonz buffer
							+ Get baseline 1:
								- DoStep: 39.99%
									- Ship::Update: 39.05%
										- UpdateDynamics: 27.42%
											- SpringForces: 20.18%
											- PointForces: 3.77%
											- CollisionsWithSeaFloor: 2.19%
											- Integrate: 1.27%
										- GravitateWater: 5.70%
										- BalancePressure: 4.58%
										- UpdateStrain: 1.03%
								- Render: 51.69%
							+ FPS=24.0/24.2/24.4
						+ 2: Do separate Position, Velocity, Force, and MassFactors 
							+ Get baseline 2:
								- DoStep: 39.01%
									- Ship::Update: 38.01%
										- UpdateDynamics: 27.44%
											- SpringForces: 19.97%
											- PointForces: 3.65%
											- CollisionsWithSeaFloor: 2.24%
											- Integrate: 1.57%
										- GravitateWater: 4.87%
										- BalancePressure: 4.51%
										- UpdateStrain: 0.90%
								- Render: 52.69%
							+ FPS=24.1/24.3/24.7/25.0
							+ Make buffer __restrict
							+ FPS=24.8/24.9/25.1
					+ If makes sense to explode:
						+ Also explode ConnectedComponent
				+ Phase 2: Springs: Points, dynamics coefficients, water coefficients, ...					
				+ Phase 2: Triangles: Points, Network
				+ Phase 2: Change all ElementContainer::ElementIndex into ElementIndex
				+ Structure of buffers:
					+ For SSE2, need to be simple floats
					+ For handling, need to be structured
				+ Buffers are class Buffer
					+ Need to be mem-aligned
					+ cctor(size)
					+ data()/size()/emplace_back()
					+ uq_ptr
			+ They expose buffer getters for each buffer (as the structured type, e.g. vec2f *, or PointNetwork *, or float * for lonely scalars)
				+ e.g. vec2f* GetPositionBuffer()
				+ When needed also exposed as floats as well (e.g. Position, for Integrate())
					+ e.g. float* GetPositionBufferAsFloat()
					+ size math left to caller
			+ When needed, they expose getters and generally operations on single elements, via 32-bit index argument (aliased as ElementIndex)
				+ e.g. void Destroy(ElementIndex)
				+ e.g. float GetMass(ElementIndex)
			+ Destroy(ElementIndex) takes care of telling ship that element count is dirty
				+ Phase 3: set directly in Ship at initiation of Destroy chain, whenever we know we destroy something
					+ Do at Spring::UpdateStrain: returns bool, true if destroyed
					+ Do at tool's Destroy
					+ Then get rid of two-phase ship cctor - plain cctor with moved ElementRepo's
						+ So can also remove move assignment at Points
			+ Pointers to points are replaced by 32-bit indices
				+ Funcs that need to follow pointers (e.g. Destroy() and SpringDynamics()) also must take whole containers 
				+ Phase 2: also pointers to Springs & Triangles
			+ ShipBuilder creates Points & moves into ship
				+ Points' ConnectedXYZ are updated at ShipBuilder time
					+ Remove code from Spring and Triangle and ElectricalElement-Cable-etc. cctors
			+ Do Ship
				+ Loop over indices, invoking Points::GetWhatever(index)
			+ End of Phase 1: FPS=22.0/22.3/22.6
			+ Phase 1.5: check assembly for:
				+ 1: loop over indices, invoking Points::GetWhatever(index)
				+ 2: loop over indices, taking buffers first and then dereferencing buffer with index
				+ RESULT: IDENTICAL
				+ Decide whether to keep bunch of GetWhatever(index) (both R and W) vs buffers
				+ Check also disassembly of index iterator
			+ End of Phase 1.5: FPS=23.2/23.3/23.4
			+ To check:
				+ UpdateDrawForces: see assembly difference for displacement.length() optimization
					+ NO, actually compiler autonomously saves length for later, and explicit
					  code looks a bit different
				+ UpdateSpringForces(): see assembly to check whether point.Force's are updated twice
					+ YES
					+ Update force once with sum of forces
				+ HandleCollisionsWithSeaFloor(): see assembly to check for twice GetPosition()
					+ YES, read once into xmm4 and re-used later
			+ End of checks after Phase 1.5: FPS=24.0/24.2/24.4
			+ Containers expose own Upload(RenderContext &)
				+ Phase 3: direct upload of buffers into GPU via RenderContext
					+ Nuke ShipRenderContext::mPointBuffer & friends
				+ Phase 3: move texture coordinates and colors into Points, which uploads
				  at Upload() via own mAreImmutablePropertiesUploaded state
					+ Nuke Ship::mIsPointCountDirty
					+ Nuke ElementRepository, as at this moment no one should be using it anymore
			+ Phase 3: Nuke PointerContainer
			+ Phase 3: Nuke ShipElement, if it's now only implemented by ElectricalElement
				+ See if managed to not need to tell Ship as well, see above
			+ Phase 3:
				+ Fix power-of-2 calculation at Buffer::cctor()
				+ Fix World::GetNearestPointIndexAt, by making use of Ship::GetPointPosition(idx)
					+ See square root optimization, here and @ Destroy()
				+ Also fix its use at MainFrame, by making use of Ship::GetStuff()
				+ Fix all warnings
		+ Phase 2: Integrate():
			+ After NewtonzBuffer exploded
			+ Test 1: use Points.GetWhatever(idx)
			+ FPS=24.7/24.8/25.0
			+ Test 2: use __restrict pointers
				+ Just simple 1-Point-Component loop, compiler makes times four
				+ Pointers are locally declared as __restrict, and adjusts count (i.e. times 2) and uses
				  indices in pointers
				+ Verify assembly
			+ FPS=24.9/25.1/25.2
		+ Phase 1:
			+ Beginning FPS=19.0/19.4/19.7/19.9
			+ Ending FPS=22.0/22.3/22.6
		+ Phase 1.5:
			+ Beginning FPS=22.0/22.3/22.6
			+ Ending FPS=24.0/24.2/24.4
		+ Phase 2:
			+ Beginning FPS=24.0/24.2/24.4
			+ After exploded Newtonz FPS=24.8/24.9/25.1
			+ Ending FPS=26.3/26.5
		+ Phase 3:
			+ Beginning FPS=26.3/26.5
			+ Ending FPS=26.6/26.8/26.9/27.0


+ Fix 4 BPP images
	+ Need ilCopyPixels to convert to standard format (BPP:3, Format: RGB, Type: U_BYTE)

+ Material::"Electrical" (and "Sound")
+ See if destroy's lack of point allows for water to flow in
+ FileDialog: filters based off image formats that are supported
+ Jelly ball: see orig code for doubles
+ Less ocean depth max	
+ Data/
	+ InitialShip.png [also change @ code]
	+ Materials
+ see if it makes sense that ship::points is set<x, set<y, points>>
+ nuke wxSmith
	+ Verify all is fine afterwards
+ set icon
+ Debug builds: 
	+ Enable /Fp:strict and set fpcontrol via /DFLOATING_POINT_CHECKS	
	+ See if SEH needed (/EHa)

+ Mouse pointer based off current tool
	+ Only on Canvas, normal outside
+ Move IsPaused member out of game controller & parameters; handled by MainFrame via status of mPauseMenuItem
+ DrawAt: the longer it's pressed, the stronger it gets
	+ Requires TimerTick to also update force and invoke DrawTo when l is down and current tool is Draw
	+ Also radius of Smash, same thing
+ Tool strength modulation:
	+ Also modulate cursor (red bar rising)
		+ Build 10 images (and then cursors) off the base image
		+ @ tool application, also call SetCursorStrength(strength, minStrength, maxStrength)
			+ Calculated which one of the (xyzCursors.size()-1) to set, of current tool's cursor

+ Phys rearc:
	+ Confirmed: destroy breaks due to iterator invalidation
	+ In order to allow for ship building unit tests:
		+ static unique_ptr<Ship> Ship::Create(unsigned char const * structureImageData, un_map<vec3f, Material*>)
		+ void World::AddShip(unique_ptr<Ship> && newShip)
		+ Game::LoadShip(filename) still loads the image, and then Ship::Create and World::AddShip
	+ Ship_BuildsFromStructureImage_XXX unit test:
		+ Make structureImageData and verify points, springs, triangles, etc., also indexes & relationships
			+ Might actually want Material::cctor to be public
	+ Destroy unit tests:
		+ Make structureImageData
		+ DestroyAt
		+ Verify points, springs, triangles, etc., also indexes & relationships
		+ Verify crashes in Debug!
	+ Do phys renames and file split above
	+ Verify unit tests (1) & runs normally & no fps regression
	+ Commit & push
	+ Take new perf baseline (FPS and percentages): 8/9
	+ Repository rearc:
		+ PointerContainer:
			+ Flag is via getter (IsDeleted())
				+ Also rename other GetIsXYZ() -> IsXYD() and SetXYD()
			+ RegisterDeletion(): increments counter
			+ ShrinkToFit: 
				+ Only if deletion counter != 0
				+ Allocate new and copy pointer by pointer that's not deleted
					+ assert counts at the end
				+ Fix unit tests (need to register deletion, and add case with no registration but deletion)		
		+ Replace parentWorld with parentShip at all elements
			+ See also if can get rid of accessing World altogether, in lieu of GameParameters or specific parameter(s) of it (e.g. gravity)
			+ Spring
			+ Triangle
			+ Point
		+ Physics::ShipElement<TElement>
			+ Provides IsDeleted()
			+ Has mParentShip * const (set via cctor) and getter
			+ public Destroy()
				+ mIsDeleted = true
				+ mParentShip->RegisterDestruction<TElement>((TElement *)this)
			+ Everything derives from it, publicly
		+ Ship maintains lifetime of points, springs, and triangles in backbones 
			+ Springs: PointerContainer
			+ Others: depends, if fast iterator access in arbitrary order is needed => PointerContainer,
				  else use set (even if never iterated, makes faster deletion)
			+ RegisterDestruction<TElement>(TElement *element): 
				+ For things in PointerContainer: invokes PointerContainer::RegisterDeletion()
				+ For things in sets, maps: invokes set/map.erase(element) // it's a shortcut!
					+ In these cases, mIsDeleted setting is redundant, but heh...
		+ Fix crash at Destroy
			+ Remove all TODOs
		+ Rethink pointer container: it should iterate Element* rather than Element&
		+ New FPS: 11/11/12
		+ Fix disappearing ship
			+ Make PointerContainer Log a Debug afterwards, instead of Info
			+ Nuke all the other TODO's
			+ Run with strict floating point
				+ Disable exc with overflow & verify that's how we get to NaN
		+ Commit & push
		+ See if chunk splitting reprocesses same point twice
		+ See if connected triangles (at point) should also be vector instead of set	
			+ Requires Triangle.DestroyFromPoint(Point *) which avoids coming back to caller, to not invalidate iterator
		+ Test mAllTriangles in PointerContainer
			+ Should make faster render:
				+ Before: FPS with pause=18/19
				+ After: FPS with pause=19
			+ If not good, undo - KEPT!

		+ Try Adjancency rearc:
			+ Commit and push first
    			+ Each adjacency arc exists for each non-hull spring, and lives
 as long as the spring lives;
			  we might then get rid of these and just visit the non-hull springs,
			  provided that we adjust GravitateWater and BalancePressure
 for the fact that each arc 
			  would now be visited only once

			+ However, for electrical elements we still want to visit the spring-connected graph,
			  regardless of hull-ness this time;
			  we then want each point to know its N attached springs (arcs), which
			  we maintain as a vector<Spring *> (there's max 8)
				+ Actually: FixedSizeVector<TElement, Size>, w/erase that shifts and returns bool
				+ Remove: use vector::erase(std::remove(val)), or self-done for just one
				+ Adjust GravitateWater and BalancePressure
 for the fact that each arc 
			  		is now visited only once

					+ GravitateWater: change to visit springs, and do realize that one of the points 
					  always has cos > and the other cos <
					+ BalancePressure: for each pair in which one has water > 1.0, do delta
					+ Don't take shortcuts, and add comments about this
				+ Point: expose same API as triangles
				+ Spring:
					+ cctor adds itself to its endpoints
					+ dctor removes itself from its endpoints
					+ Make sure it's the same code as triangles
					+ Then remove code from Ship construction
				+ Replace adjacencymap visit with spring visit (of non-hull only)
				+ Remove ship.adjacencymap
				+ Requires Spring.DestroyFromPoint(Point *) which avoids coming back to caller, to not invalidate iterator
			+ Then see if Point->Destroy() can avoid enumerating all springs to find the ones affected
				- Check speedup
		+ x::Destroy()  // Removes all references to self that are found in counterparties
				// Invokes Destroy() on counterparties it "owns" (e.g. Point->Spring)
				// Basically: replaces dctors (which now have to go away)
				// Then, calls base ShipElement::Destroy()
		+ At the end of each Update(), Ship calls shrink_to_fit on owned pointer container(s)
			+ Also removes points et al that were deleted on previous DestroyAt()
		+ Remember to exclude IsDeleted() things during enumerations!
			+ And assert(!IsDeleted()) when it's impossible the're deleted (e.g. if accessed via relationship that should
			  have been cut if that element was deleted)

	+ Remove TODO's from unit test and verify (2) & runs normally & no fps regression
	+ Complete unit tests with all new relationships
	+ Commit & push
	+ Take new perf baseline (FPS)

	+ Final refactor physics:
		+ No friends
		+ Clear all warnings
		+ Args by ref - no vector copies!
		+ phys getters (e.g. point.GetColour()) inline
		+ Make other inlines
		+ Fix include files	
		+ Formulas optimizations
			+ Point forces: gravity may be applied twice with different magnitude but same vector
		+ gameparams/world::(waterpressure, strength, ): are these "factors" or "global" really?
		+ See if FP:fast really makes a difference (Release only)
		+ All TODO's
	+ Commit & push
	+ Verify unit tests & runs normally & no fps regression
+ Menu entry to reset pan and zoom
+ Get rid of unicode
	+ Can, really?
+ Add splash screen


+ Controls:
	+ Smooth pan and zoom
		+ Takes 1 sec to get to final value (which is stored immediately as real value)
	+ Zoom: inverse
		+ 0 - 1000
		+ Renderer::ZoomToWorldY(zoom) == 70/(zoom + 0.001)
		+ Also called by GameController's Screen2World 
			+ also move GameController's Screen2World implementation to Renderer
		+ See if needs to be exponentially-slider'ed as well
	+ Settings:
		+ Strength Adjustment must be settable exponentially (slider=>exp)
			+ Formula done by gamecontroller at AdjustStrengthAdjustment(), or by SettingsDialog directly
	+ Page up and page down in menu
	+ Ship name in title
		+ MainFrame implements OnShipLoaded() and OnGameReset(), populates mShipNames vector with ship names, and calls SetTitle()
		+ SetTitle appends Utils::Join(vec<str>, ' + ') to current title
	+ Radio: draw points, springs, structure, texture
		+ (Bit) Flag @ GameController->RenderContext->Ship
			+ Inspected as bit glag by Ship as well @ Render() to avoid useless uploads
		+ Larger points
		+ SettingsDialog
			+ Better grouping, see RadioBox?
	+ Space bar for pause
		+ When pause, also pause sounds and music
	+ MainFrame: AboutDialog is member & shown on demand
	+ Make stiffness adjustment
		+ Points::SetStiffnessAdjustment(stiffnessAdjustment):
			+ Called by Ship at each Update()
			+ If != last, recalc coefficient/s
	+ Set max and min zoom (or monsters awaken when you zoom out too much)
	+ Reset view (ESC) should also reset camera pan
	+ SettingsDialog: bomb blast radius
	+ SettingsDialog: 
		+ Break into N Liner/ExponentialSliderControl
			+ Init'd with:
				+ CurrentValue
				+ Max and Min
				+ std::function for OnValueChanged(float newValue)
		+ Find solution to ugly slider value rounding
			+ Calc tick_size == (Max-Min)/100, floored to round float increment ... see doc'n on floats
			+ Then calc # ticks == floor((Max-Min)/tick_size)
		+ Re-set default values to round values
	+ Tool cursors: cursor should change when mouse down
		+ Remove up and down from hierarchy - no cursors in hierarchy (other than mCurrent), and ModulateCursor()
		  takes vector
		+ Do own up and down at:
			+ Smash
			+ Grab (times 2: positive and negative)
		+ Pin, instead, does not change
			+ Undo its dual cursors
		+ ToolController class, called directly by MainFrame
			+ Has GameController shared_ptr
			+ SetTool(tool enum from ToolController)
			+ OnMouseDown/Up/etc.()
			+ RC Bomb detection via events is still left to MainFrame
			+ Tool class:
				+ ToolController has pointer to the current tool; might be null
				+ ShowCurrentCursor(): shows the current cursor; invoked by ToolController at end of initialization
				  to show the first cursor, and might be invoked via ToolController by MainFrame in the future
				  to re-show cursor after having stolen it
			+ Test:
				+ Shift up and down detection
	+ View control smoothing: test with restart from last target for faster convergence
	+ Up MaxStrength
	+ See why waves change when settings dialog is opened and closed
		+ Problem with ocean depth: value on exit looks like current - min == 180
		+ First of all, need to set slider ticks based on current values upon opening of dialog
		+ Then, see if floor at linear control should be round
	+ Fix ambient light increments
	+ When wind is zero waves don't move - need to change wave height and phase separately	
	+ Changing the height of the bumps of the ground
		+ Allow the minimum seabed height to be 0
	+ Being able to drop the sea floor much further down than 500m or so too, like 10km
	+ World settings: number of clouds, wind

	+ SettingsDialog: also sound options
		+ Turn on/off sinking music
		+ Stress sounds on/off
		+ Break sounds on/off
		+ Two volume controls for music and sounds (all but music)

+ Gfx:
	+ Do ropes with two endpoints (000xxx)
		+ Throw exception if doesn't find two endpoints
		+ Algo: 
			+ Step 1: build vector<PointInfo> & Matrix<opt<pointIndex>> & vector<RopeInfo>
			+ Step 2: visit RopeInfos and add to PointInfo's and SpringInfo's
			+ Step 3: visit PointMatrix & ...
		+ Starting perf:
			+ Default ship: 14.1/14.3
			+ Ropes test: 12.2/12.3
		+ Need to always use color when rendering springs:
			+ Spring::Type (Hull, Rope)
				+ No exposed, just IsHull() & IsRope()
				+ Make it a bit flag
			+ Separate RenderContext method for Ropes, stored in separate Element (RopeElement, structurally == SpringElement)
				+ Upper bound for # of spring ropes given # of points in connected component:
					+ N
					+ Upper bound of 'normal' springs doesn't change
			+ Render: draw ropes after springs and triangles (we want them on top of triangles!), still by connected component
				+ Use own program
		+ Ending perf:
			+ Default ship: 14.2
			+ Ropes test: 12.3
		+ Don't make triangles of 3 rope points if at least one is connected to ropes only
			+ Fix Base III?
		+ Flip order of rendering when structure: triangles first, then ropes
			+ Need private subparts of Render()
		+ Ending perf:
			+ Default ship: 14.5
			+ Ropes test: 12.3
		+ Add ropes to Titanic
			+ Make wood non-hull
		+ Fix unit tests
		+ Make max(fixedSizeVector) == 9
			+ Not for triangles - generated rope points will never participate in triangles
		+ Material/Rope rearc:
			+ MaterialDatabase
				+ Loads itself from json
					+ From ResourceLoader invoked by GameController at init'n
				+ Guarantees:
					+ Exactly one material with isRope=true
					+ Color is #000000
					+ No colors clash, and no colors fall within rope range
				+ Replace in GameController, ResourceLoader
				+ Remove ropeMaterial kung-fu @ Ship::Create and use material->IsRope
				+ GameController also gives rope renderColour to RenderContext at cctor
					+ Which sets shader's hardcoded parameter
	+ Try light diffusion rearc:
		+ No more at C++, but rather in OpenGL as in the following example (written for ShipTriangles only but valid also for springs 
		  and points):
			+ Prerequisite: draw ship triangles by connected component (see above)
			+ Turn off diffusion
			+ For each component: pass array of all lamps in that component; each lamp has {x, y, intensity};
			+ Draw each connected component N times (use additive blending), once for each lamp, 
			  each time passing the single lamp properties as uniform to shaders, 
			  which calculate distance and do final light blending
				+ Check right way of doing blending
		+ REJECTED: perf was awful; this multiple-pass way of doing it hurts too much

	+ Texture mapping:
		+ UploadLandAndWaterStart()/./End()
			+ Just specify land y and water y
			+ Impl:
				+ y:
					+ To LandBuffer
					+ To WaterBuffer
			+ RenderLand()
			+ RenderWater()
		+ Land (sand)
			+ bottom is not anymore a param but it's filled by RenderLadn(.) with +/- mWorldHeight/2
				+ only param is x and y (world y)
			+ texture coordinates are world coordinates
			+ Magic number is based on desired tile world size
		+ Water
			+ Use "water transparency" uniform in shader that sets alpha value in result of texture
			+ Make texture stretch wrt vertical height of water strip
			+ Change map, this one's ugly
		+ Clouds
			+ Use N textures, each has own rectangular size
			+ RenderContext loads all available textures and uses them for the clouds, modulo
				+ ResourceLoader::LoadTexturesRgba(prefix)
					+ initProgressSink lambda 
			+ GameParameters.NumberOfClouds (constants)
			+ World takes numberOfClouds and allocates clouds buffer with random values
			+ Then, RenderContext::RenderCloudsStart()/./End()
				+ Buffer contains virtualX and virtualY, and scale
				+ RenderContext::RenderCloud() makes rectangles (in world coords) based off formula
			+ Clouds stencil: 
				+ Draw waterbuffer without texture, but reverse stencil op
		+ Ship, using second image
			+ Load ship == image or .shp (JSON)
			+ First, try naively with just point colors
				+ Doesn't work, as structural image has too little resolution
			+ RenderContext is given optional texture image (by GameController) via
			  RenderContext::AddShip(iShip, opt<ImageData>)
			  + Requires RenderContext::ResetWorld()
				+ Simply clears vector of ShipRenderContext()
					+ ShipRenderContext contains everything ship-related
						+ Rename springs and triangles to "Elements"
						+ Touch points with outside world:
							+ Parameters (booleans, render factors)
							+ OrthoMatrix
							+ Helpers
				+ No need to reset others (land, water, clouds) as their numbers, positions, and data will be given
				  at the next Render() from scratch
					+ But it could easily by re-creating uq_ptr<XYZRenderContext()>
				+ Call from GameController
			  + Adds ship with opt<ImageData> in arg
				+ If specd, cctor creates <OpenGLTexture mElementTexture> and uploads immediately
				+ mShipTextureCoordinatesVBO and other texture machinery is created at startup anyway (if any)
				+ No need for std::optional<ImageData> TextureImageData
			  + Remembers if ship has texture via mElementTexture
			  + Catch exceptions at all interactions of MainFrame with GameController, and display DialogBox
			  + ResourceLoader::LoadShipDefinition: need to make paths abs wrt .shp path
			  + Refactor to World::CreateShip() -> ID -> Ship::Create()
			  + Land and Water texture names: do own, not from array
			  + Always unbind texture2d after a render
			+ Also, later, RenderContext is also given textureCoords,
			  i.e. a buffer of texture X's and Y's (i.e. initial points' coords) for
			  each of the ship points (i.e. aligned with the point buffer which will be continuosly uploaded)
			  + TextureCoords created by Ship::Create (always), stored into Ship, and given to RenderContext
			    (which uploads it, always) once and for all at the same time as colors (i.e. when IsPointCountDirty)
			+ If a texture is associated with the ship, RenderContext uses a different shader for ShipTriangles
			+ Krafting:
				+ Y offset for initial drop
				+ Remove one layer of hull from bottom, but see how much it bends afterwards

	+ Draw stressed springs with their own hardcoded texture (1D, 3 pixels: red, red/white, red) of a reddish line with "hot" centre
		+ https://stackoverflow.com/questions/17866308/texture-a-line-in-opengl
		+ Make it a 2D with semicircle around T,L corner
			+ textureCoords are inputPos
	+ Fix springs showing up around texture from structure
		+ Make test .shp with three masses and a rope
	+ Draw points:
		+ Ship uses RenderContext::UploadPoint(elementIndex), only for !deleted points
		+ Then, glDrawElements(GL_POINT)
		+ Nuke PointProgram as it's dupe now
	+ RenderContext:
		+ Get rid of pre-generated texture names and create on-demand
			+ Test!
		+ See if can describe point, color, and texture VBOs at init
	+ Should draw each connected component at once
	+ ShipTexture: Experiment with different min/mag filters
		+ Try mipmaps, should help make the Titanic artifacts disappear
			+ OpenGLGame::UploadMipmappedTexture(imageData) -> void
				+ Does base and all the dimensions down to 1x1, using floored extents
				+ Algo: take avg of each square of points, including alpha
			+ Use GL_LINEAR_MIPMAP_LINEAR
			+ See https://www.khronos.org/opengl/wiki/Texture
			+ Then nuke ImageData stored in RenderContext's
			+ Use at:
				+ Ship
				+ Remove from Land? Test w/out and see if border
			+ Test perf
	+ VectorField rendering
		+ Final cleanups:
			+ Check all vector fields wrt deleted points
			+ RenderContext: initialize vector render mode to None
			+ Make vector field render mode changeable in SettingsDialog, Render tab
			+ Add length adjustment as render parameter, multiplied by RenderContext before passing to ship
				+ No dialog adjustment needed yet
	+ ShaderManager
		+ WetColor, LightColor: make them static hardcoded params
		+ Use in and out, and 130
		+ Replace all shaders
			+ RenderContext
				+ Use "in" as prefix of inputs
				+ glEnableVertexArrays: all at top, as they have nothing to do with VBOs
					+ ShaderMgr enables all the used ones
					+ Ship/RenderContext Code only disables zero when it's not used
			+ ShipContext
				+ Ship/RenderContext code only disables zero when it's not used
				+ Remove unnecessary bind's for VBO's that source dedicated attributes
		+ Get rid of vector_arrows shader, use matte
			+ Will need to re-bind attribute (GenericPosition or VectorPosition=0) to vectors VBO
			+ Deep cleanup
				+ enums
				+ shader
		+ Replace glBufferData with glBufferSubData when size does not change; at Ship only:
			+ Point positions, color, water
			+ Check perf before and after:
				+ Pre: 26.6
				+ Post: 27.3
	+ Fullscreen:
		+ ESC to go out, menu option/F11 to fullscreen again
		+ Add to changes
		+ Text at RenderContext
			+ Do Render:: move
			+ Render::Font
				+ Loads itself like TextureDatabase, with IProgress
				+ Owned by Render::TextRenderContext, created at cctor
					+ Render::TextRenderContext owned by Render::RenderContext, which fw's all calls to it
				+ Has method to calc pixel size given char* and size_t
				+ Has method to append vertices given char* and size_t
					+ Returns # of vertices appended
			+ TextRenderContext
			+ TextLayer:
				+ Owned by GameController, which FW's to it
				+ SetEnabled(bool)
			+ Debug:
				+ glCheckError macro at GameOpenGL.h
					+ Make it inline
					+ Use it at RenderContext and ShipRenderContext setup and rendering, instead of various checks
			+ Cleanup Font.h
			+ Add & change StatusText font
			+ See response to Toggle Status Text
			+ Do better initial text (invoke at MainFrame cctor)
			+ Update AboutBox and tell guy
			+ Check perf
			+ Perf optimizations:
				+ Precalcd stuff in FontMetadata, indexed by char

+ Gfx Optimizations

	+ Try without buffer population: 			
		+ Point has vec2f * const mPosition and vec2f * const mColour, pointing into two fixed buffers
			+ vectors are packed (static_assert on contiguous 2 or 3)
			+ Point does not live in PointerContainer but in std::uq_ptr<Point>[]
				+ Delete does nothing (Destroy does relationships though), just marks it
		+ Point also has mElementIndex, queried by springs and triangles when rendering themselves
			+ Can make Ship::Render const again, then
		+ Pointers to fixed buffers (as arrays of vectors) are owned by Ship and
		  are given by Ship to RenderContext at each Render via 
		  RenderContext::UploadVertices(vec2f*, vec3f*, count)
		+ RenderContext usage of two buffers at each DrawElements:
			glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
			glVertexAttribPointer(vertexPositionAttribute, 3,  GL_FLOAT, false, 0, 0);
			glEnableVertexAttribArray(vertexPositionAttribute);
			glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);
			glVertexAttribPointer(vertexColorAttribute, 4, GL_FLOAT, false, 0, 0);
			glEnableVertexAttribArray(vertexColorAttribute);
		+ Point's vector pointers are populated by Point::Rebase(buf1, buf2),
		  invoked by Ship at construction
			+ Rebase() uses mPointIndex (rename of mElementIndex) to calc pointers
		+ Try: could also use buffer with mLight and mWater (uploaded each time to GPU as well) to be used by V->F shader 
		  to blend fragColor with two fixed colors (water blended before ambient light, light after)
			+ F shader needs to start doing ambient light now, rather than point
			+ Need Point::CalculateWaterColorIntensity() (clamps and copies mWater to buffer), 
			  and a dummy Point::FinalizeLightColorIntensity() (dummy because mLight is already finalized)
			  + or do clamp in shader, so use mWater and mLight straight from buffer, no CalculateX() needed
			+ If we put light and water in shader, then we don't need to reupload color buffer each time
		+ Bonus: also test GPU interpolation of mLight and mWater by emitting them at vertex
	+ Plan:
		+ 0: Test with additional mLight and mWater uploaded to RenderContext (same Point struct), and fragment shader doing math
			+ F Shader needs params: ambientLightIntensity; constants: waterColor, lightColor
			+ Remove point color calculation
			+ Check perf:
				+ Before: 16
				+ After: 14.1
				+ Keep in mind that we're adding to the buffer, while later we'll remove the colors
			+ Also test bonus: GPU interpolation of mLight and mWater by emitting them at vertex				
		+ 1: if OK: PointCore struct (@GameLib) with {position, light, water}, based into Point
			+ Separate color buffer: 
				+ Color struct (vec3f) has static_assert's for alignments
				+ Created by Ship::Create(), moved into Ship member (ElementRepository<vec3f>)
				+ Uploaded one-shot at first Ship::Render()
					+ via RenderContext::UploadShipPointColors(vec3f *, size_t elementCount):
						+ Uploads to GPU right away, with GL_STATIC_DRAW
						+ Stores size (mShipElementCount) for later assert
			+ Check perf: 14.2
			+ Commit 
			+ Separate PointCore buffer:
				+ PointCore struct has static_assert's for alignments
				+ Created by Ship::Create(), moved into Ship member (ElementRepository)
					+ Points have already been based, at cctor by Ship::Create()
				+ Uploaded at each Ship::Render()
					+ via RenderContext::UploadShipPoints(PointCore *, size_t elementCount):
						+ Asserts size same as color buffer (mShipElementCount)
						+ Then uploads to GPU right away, with GL_STREAMING_DRAW
		+ Final:
			+ Nuke Point::CalculateColour
			+ Also do light/water color blending at ship *point* fragment shader
	+ Only keep separate color buffer and water/light done in F shader; point disembodiment was not a good idea

	+ Pack vertex attributes @ other shaders:
		+ clouds
		+ text_ndc
		+ FPS: 28.2/28.4

	+ Reduce # of bind VBO calls by delaying upload of buffers we own until we bind the VBO for drawing
		+ Land at RenderContext::UploadLandAndWaterEnd/RenderLand
		+ Also disable vertex attribute index zero once
		+ Test all ship shaders with 2 connected components
		+ FPS: 28.5

	+ Use MapBuffer when we know the sizes in advance, eventually re-allocating GPU buffer when the size changes
		+ Clouds
			+ Rename middle "RenderCloud" as "UploadCloud"
			+ Rename SharedAttribute1 as SharedAttribute0, et al
		+ Land, Water
			+ Also make clouds, land, and water use disjoint vertex attributes, so can bind once at each XYZStart()
			  before mapping buffer (and subsequently describe, when needed)
			  + Water, matte_water: use vec3 WaterAttribute
				+ Shaders
				+ RenderCore
				+ Description, once at initialization
				+ Disable 0 before running program
			  + Clouds: use vec4 SharedAttribute0
				+ Shaders
				+ Bind, allocate, and map at RenderStart()
				+ Description at Render() after unmapping buffer
				+ Enable 0 before running program, after description as usual
			  + Land: use vec2 SharedAttribute1
				+ Shaders
				+ Bind, allocate, and map at RenderStart()
				+ Description of SharedAttribute1 at Render() after unmapping buffer
				+ Disable 0 before running program
		+ FPS: 28.1/28.3/28.4
	+ Now, compare with replacing MapBuffer with BufferSubData
		+ Copy exe first
		+ Just this:
			+ Replace mXYZMappedBuffer with std::unique_ptr<XYZ[]>
			+ (Re)allocate buffer whenever we (re)allocated GPU buffer
			+ Remove MapBuffer call
			+ Replace UnmapBuffer call with BufferSubData
		+ FPS: 28.2/28.3/28.4
	+ Get full perf, including other laptops
	+ Texture atlas:
		+ Spec:
			+ Atlas is built on-the-fly, completely independently from texture DB, via a separate
			  component (TextureAtlasBuilder) that is given multiple TextureFrame's and eventually spits out TextureAtlas
			+ TextureAtlas:
				+ Contains:
					+ image: consumed by GameOpenGL helper for mipmapping
					+ metadata: used by GameOpenGL helper for mipmapping, owned by RenderContext (for clouds, land, and water) 
					  and (by reference) by ShipRenderContext (for GenericTextures)
				+ Structure:
					+ ImageData Texture
					+ TextureAtlasMetadata Metadata:
						+ TextureAtlasFrameMetadata:
							+ box in atlas (i.e. texture coords, as 2xvec2f)
							+ TextureFrameMetadata
						+ vector<TextureAtlasFrameMetadata> / anything else addressable via TextureFrameId (see above)
			+ Separate mipmapper helper in GameOpenGL takes ImageData (by move) and TextureAtlasMetadata
		+ Impl:
			+ Phase 1: Clouds
				+ TextureAtlas
				+ ResourceLoader::SaveImage
				+ Resize all clouds to powers of two
					+ Test look & feel
				+ RenderContext: 
					+ Cctor: create atlas and add just Clouds
					+ Upload texture - w/no mipmap for the time being
					+ Store Metadata (by value) and handle
					+ Use Atlas metadata at UploadClouds()
				+ Test 1
				+ Get rid of need to use TextureRenderManager at RenderContext for clouds
				+ Draw all clouds together at once
					+ Need triangles
				+ RenderContext:
					+ Call GameOpenGL mipmap helper moving Texture and passing Metadata
				+ Test 2
					+ FPS: 28.5/28.6/28.7
			+ Phase 2: Generic Textures
				+ Resize all generic textures to powers of two
					+ Pin
					+ RC Bomb
					+ RC Bomb Ping
					+ Timer Bomb
					+ Timer Bomb Defuse
					+ Timer Bomb Explosion
					+ Timer Bomb Fuse
					+ RC Bomb Explosion
					+ Timer Bomb Explosion
					+ Test look & feel
					+ Fix timer bomb issue
				+ Fix texture coordinates in atlas to be between 0.5/dim and 1-0.5/dim
					+ Test it first simply at current generic texture upload
					+ See Moleskine
					+ Do in atlas UV coordinate generation
				+ RenderContext:
					+ Cctor: add entire database to atlas minus land and water
						+ Make builder stateful
					+ Pass Metadata and texture handle to ShipRenderContext
					+ Bind:
						+ Atlas before clouds
						+ Land, Water before land and water
				+ ShipRenderContext must take from RenderContext:
					+ Atlas texture handle (&), for binding it at GenericTextures
						+ At least until we do Z and GenericTextures moves up to RenderContext
					+ metadata (&)
				+ ShipRenderContext:
					+ Bind atlas at GenericTextures
					+ Use box in atlas at Generic Textures upload
					+ Modify GenericTexture to run once for all textures (still for each connected component until Z)
						+ Populate quads directly in connected component GenTexElement vector
							+ Make room as needed (emplace_back)
							+ Store max size among all connected components in SRC member
						+ Upload connected component GenTexElement vector at RenderGenericTextures()
							+ Realloc buffer if new max size != m allocated max size
							+ Then always BufferSubData
						+ Test with multiple connected components
					+ Nuke TextureRenderManager member and cctor arg
					+ Cleanup RenderContext's upload of textures				
			+ Remove test saving of atlas

	+ Figure out what's most expensive with perf analysis and noinline
		+ Only triangles: 42fps
		+ Triangles and ropes: 42fps
		+ Only springs: 32fps
		+ Is it stenciling, flushed at Ship::RenderEnd()?
			+ With no stenciling: FPS: 29.4/29.5
	+ Enable stenciling only when needed
		+ FPS: 29.0
	+ Try Render1/Update1/Render2/Update2
		+ @ GameController and down
		+ No improvements
	+ All textures: test changing GL_LINEAR_MIPMAP_LINEAR to:
		+ GL_LINEAR_MIPMAP_NEAREST
		+ At:
			+ Land and Water
			+ Atlas
	+ In texture or structure mode, draw only springs that are visible
		+ i.e. springs with # of triangles < 2
		+ Impl:
			+ Springs:
				+ New buffer: SuperTrianglesCount - type: ElementCount
					+ Publicly exposed
					+ Populated via argument at Springs:Add
						+ Calc'd by ShipBuilder via Triangles below, during component springs discovery
					+ Decremented via Springs::RemoveSuperTriangle() // no args
			+ Triangles:
				+ New buffer: ComponentSprings - type: std::array<ElementIndex, 3>
					+ Publicly exposed
					+ Populated via argument (of type std::array<ElementIndex, 3>) at Triangles:Add
						+ Calc'd by ShipBuilder
					+ Never changed
					+ Used by Ship::TrianglesDestroyHandler() to decrement count for each component spring
			+ Triangle destroy: remove self from springs
			+ Springs destroy: remove self from super triangles
			+ ShipBuilder:
				+ Adjust to new
				+ Also take care of traverse springs
			+ New ShipRenderMode: EdgeSprings only
				+ ShipRenderContext: treated exactly like SpringsOnly
				+ Springs::Render: used to decide what to upload
			+ Springs::UploadElements: in all modes except SpringsOnly, upload only springs with # of super triangles < 2
				+ Re-enable TODOTEST code
			+ Ship::Render() has to remember what ShipRenderMode was used last time, so to consider elements dirty
			  also when ShipRenderMode has changed

	+ See if can use multiple texture units
		+ Bind once atlas, land, and water at cctor, to each unit
		+ Change shaders to have one single texture sampler param, and set uniform locations to texture unit
		+ Do only for clouds, generic texture, land, and water
			+ Revert RenderContext.cpp, ShipRenderContext.cpp, TextRenderContext.cpp
			+ Fonts and ship stay as before, they use texture unit 0 - SharedTexture
			+ Shaders
			+ Remember to activate texture unit 0 before binding, at:
				+ Ship texture, stressed spring texture, font
		+ Fix: land, generic
		+ : test
		+ Replace calls to glActiveTexture with ShaderManager::ActivateTexture(parameter)
		+ Fix/Recheck progress bar
		+ Redo perf FPS measurement




+ Dynamics
	+ Try half of the relaxation iterations
		+ Might need to adjust stiffness
	+ Adjust springs stiffness
		+ Test other values:
			+ 0.1 => should break faster : YES
			+ 1.7: explodes
		+ Test with same strain also for compression	
			+ And force at 0.0058
		+ Test with slightly higher stiffness - see if less bending but same breaking
	+ Realistification:
		+ Ship::Damp: damping 3 times at end should have the same effect
		+ Exploding ship:
			+ Check if higher damp factor helps: was 0.5, now 0.8
		+ Spring equilibrium: 
			+ Find right overshooting factor (may be slightly smaller)
			+ Compare behavior with old game
				+ Steel Ball and broken default ship in old game: explodes? yes
	+ Test completely force-driven dynamics:
		+ Create branch
		+ Each iteration (test initially with 1 iteration per step; then see with more, but scale dt)
			+ Apply forces: 
				+ For each spring:
					+ Spring force (Stooke's law - need k, try fixed at first)
					+ Damping (try along spring first - like now)
					+ see https://www.scss.tcd.ie/Michael.Manzke/CS7057/cs7057-1516-14-MassSpringSystems-mm.pdf for equations
			+ For each point:
				+ Gravity (with buoyance)
				+ Drag
			+ Apply verlet integration
			+ Zero force
			+ ...do tension strain check...
			+ ...electrical and water...
		+ Improve:
			+ Masses				
			+ Gamma - from original (NOT from original, doesn't work)
			+ Better grab force:
				+ Have optional<float force, vec2f position>; at each iteration, if not none:
					- Do force spreading with force/NumIterations
				+ Also, all non-static GameParameters initialized at cctor in cpp				
				+ Check ropes afterwards
			+ Collision with sea floor and (original) "bounce"
				+ v += adjusted Pos - pre-adjusted Pos
				+ Double-check new V
			+ Make SimulationStep a templated constant (double and float)
			+ Clean up code
		+ Perf:
			+ Get baseline:
				+ FPS: 15.8
				+ GameController::DoStep: 44.98%
					- UpdateDynamics: 32.96%
						- UpdateSpringForces: 15.33%
						- UpdatePointForces: 8.51%
							- GetWaterHeight: 5.24%
							- fminf: 1.23%
						- SeaFloorCollisions: 5.40%
							- GetOceanFloorHeight: 3.69%
						- Integrate: 3.71%
					- BalancePressure: 5.70%
					- GravitateWater: 4.30%
				+ MainFrame::Render: 46.67%
			+ Do constants
				+ FPS: 16.15
			+ Do Spring.XYZFactor/s
				+ See if can get rid of dt parameter in funcs
				+ FPS: 16.25
			+ Do Point.MassFactor
				+ const calc'd at cctor via GameParameters::dt and GameParameters::numIterations
				+ See if can get rid of dt parameter in funcs
				+ FPS: 16.50
			+ Do cached WaterHeight and ocean floor height
				+ Also useful for LeakWater()
				+ If period chosen wisely (< expected ship world width), saves on calculations
				+ Physics::WaterSurface class, only visible by World, which exposes own getters
					+ cctor(): allocate buffer
					+ Update(currentTime, gameParameters): populate buffer
					+ GetWaterHeight(x): 
						+ Convert x to absolute sample index, via dx and taking floor
						+ Interpolate height between asi%buffer_size and (asi+1)%buffer_size
				+ At end:
					+ Remove gameParameters from World::GetWaterHeight and cleanup World.h
				+ Optimize
			+ Get baseline:
				+ FPS: 17.0/17.2
				+ GameController::DoStep: 41.85%
					- UpdateDynamics: 28.10%
						- UpdateSpringForces: 13.90%
						- UpdatePointForces: 5.87%
						- HandleCollisionsWithSeaFloor: 4.27%
						- Integrate: 4.24%
					- BalancePressure: 6.47%
					- GravitateWater: 4.88%
					- LeakWater: 0.22%
				+ MainFrame::Render: 48.99%
			+ Test fma in Integrate()
				+ check assembly: REJECTED, it's function call!
			+ UpdateSpringForces:
				+ Don't check for IsDeleted, but just set coeff's to zero for deleted springs
				+ FPS: 17.4/17.5
			+ Spring::WaterPermeability
				+ Set to 0.0 if hull spring or deleted, else 1.0f
					+ Set at cctor
					+ Set to 0.0 at Destroy() ("...avoid draining water to destroyed points...")
				+ Remove two if's at BalancePressure and GravitateWater
				+ FPS: 17.3/17.5
	+ Set springs' K in material
		+ Multiplies with C (0.8) in Spring::CalculateStiffnessCoefficient()
		+ Fix Titanic masts
			+ See if need to increase iterations
			+ Testing wood: 1.10 to 1.15
		+ Fix ropes (they don't move as fluid and continuous as before)
			+ Test with own K for ropes (start with half K)
		+ Change exponential of StrengthAdjustment, for expanded small values
			+ 0.001+((exp(x/70)-1)/2.3)^3.4
			+ Verify inverted formula
			+ finalize default StrengthAdjustment: 0.03421?
	+ Pin points
		+ Point::TogglePin():
			+ If pinning: set MassFactor to zero, and set velocity to zero
			+ If unpinning: recalc MassFactor (using same helper used at cctor)
		+ The entire search is implemented by Points
			+ Together with isPinned (used at search to avoid pinning pinned point), also maintains
			  stack of pinned point indices
				+ Toggle: find topmost point in stack merely within radius; if found -> toggle it & remove from stack 
				  & mark as dirty for re-upload and return true; 
				  + else: find closest non-pinned point; 
					+ if found: toggle it & add to stack & mark as dirty for re-upload & return true
					+ else: return false
				+ Destroy: also remove from stack, if there
					+ And if there, mark as dirty for re-upload
		+ Given that connected component changes affect rendering of pinned points:
			+ Move stack and mArePinnedPointsDirty back into ship, together with search logic
				+ Points gets back Pin() and Unpin()
				+ Ship::Destroy as well
			+ Pinned points are uploaded by decision of Ship
				+ Decision: if mAreElementsDirty || mArePinnedPointsDirty
				+ Ship does start & end & points
		+ ShipRenderContext: draw pinned points using texture (centered)
			+ Ship uploads coordinates and ConnectedComponentID of point
			+ ShipRenderContext: behave exactly as with StressedSprings (i.e. reset at ElementsStart()), as 
			  we're sure we'll re-upload pinned points when elements are dirty
				+ Rename as "Elements"
				+ Do with buffer
				+ Calc bounding box, centered over point, like clouds
			+ Render(): draw at very end of each connected component render, after stressed springs
			+ Redo cursor and move to \textures
		+ Tool just toggles:
			+ Ship checks if exists pinned point in radius: if yes, unpin; else, pin
			+ Returns true if points belongs to ship, so to stop search by World
			+ Cursor is a pin
		+ ShipRenderContext::UploadPinnedPoint(): do pinned point insertion at end of own connected component
		+ Texture: 
			+ lighter
			+ plug hole
		+ Fix crash when loading Titanic
		+ Max 64 pins
			+ CircularList
				+ Add() is templated on OnRemoved() handler
					+ When over, older are removed
				+ Unit tests
			+ Constant at GameParameters
		+ Spring deletion at stress: also unpin endpoint if the endpoint has no more springs attached to it
			+ Requires global destroy handler above
			+ Do at Ship::SpringDestroyHandler
		+ SoundController reacts to IGameHandler event (true/false) with two sounds (Pin/Unpin)
			+ Random choices, Over/Underwater - NO material
				+ Update sink event
			+ Do sounds:
				+ 4 pin
				+ 4 pin underwater
				+ 4 unpin
				+ 4 unpin underwater
	+ Find sweet spot of stiffness and strength between bending and more strength for pinning
		+ stiff: 0.500750
		+ strength: 0.006200
			    0.005376
		+ pinning: fine (can't pin when it's very fast)
		+ wood: 2.0 (titanic masts like before)
		+ new titanic structure
	+ Cosmetics:
		+ Explain Spring's coefficients (in terms of fractionXYZ* of return-to-rest-length, etc.)
		+ Rename Points::MassFactor as IntegrationFactor and explain
	+ Is Verlet implemented right?
	+ Review parallel calculation, it suffers from races
		+ Also See if can continue queueing tasks without waiting for all blocks of chunks
	+ Bombs:
		+ Spec:
			+ Placed and removed with similar tool as Point Pinning
			+ Two types of bombs: timer and remote controlled
			+ A bomb explodes when:
				+ Its timer times out or the remote control is triggered
				+ The point it's attached to is destroyed 
				+ A point or spring in the "neighborhood" (a separate, small radius) is destroyed (includes nearby explosion)
			+ When one or more bombs are detonated, ship needs to know only position, connected component ID, and blast radius, 
			  not even point index
				+ Thus (exploded) bombs are independent from lifetime of point that they were attached to,
				  allowing ship to destroy point immediately at first step of detonation, for example
				  if we have multiple-step detonations
				+ By not using point index we allow explosions to affect multiple connected components (of same ship though)
			+ Bomb decides for itself when it's to be deleted, and Bombs consequently removes it from
			  collection (and from point indirectly via Bomb::Destroy which, if attached to point, calls Points::Detach)
				 
		+ Impl:
			+ Final test
			+ TEST: bombs are attached to springs instead of points
				+ Move isAttached buffer from Points to Springs
				+ Move mass trick to springs
				+ Bomb position becomes positionA and positionB (bomb attached across)
					+ Also BlastHandler argument is positionA and positionB
					+ Blast calculated's by ship from middle point
				+ inline Springs::GetPointA/BPosition(Points const &)
				+ Points::SetMassToMaterial(float ~offset)
				+ Restructure positionA and positionB:
					+ Freeze position and rotation offset, not positionA and positionB
				+ Fix calculation of alpha - check just zero
			+ TEST: lead-in: continuate ping counter, just different velocity and different translation to frame index
			+ TEST: 360 rotation
			+ Fix mass augmentation
				+ Also update springs' coefficients
			+ Fix blast flipping
			+ TEST: run in debug
			+ FIX: first blast handler is so small that it doesn't find point in radius
				+ Go linearly from 0.6 to BlastRadius
				+ At end, re-enable texture frame for explosions
			+ FIX: ContinuousSound start while paused issue
				+ DesiredState
			+ FIX: TimerBomb x,y offsets
				+ Restore cursor hotspot
				+ Add temporarily fixed world offset at ShipRenderContext
					+ Desired center: 147, 228 off 300, 300 => +3, -78 over 12.0, 12.0 makes 0.12, -3.12
				
			+ Bomb base class, w/type enum
				+ Update(OnBombExplosionStep(position, radius)) -> bool = 0: 
					+ Runs state machine with local clock
						+ Advances animations (textures of bombs, sounds via events)
					+ Invokes handler for each explosion step
					+ Returns false when needs to be deleted
				+ GetRenderFrameIndex() -> size_t
					+ Specialized for state machines
				+ NeighborhoodDisturbed() = 0
					+ Invoked when needs to explode because own or near point is disturbed
			+ Two subclasses - TimerBomb and RCBomb
				+ RCBomb:
					+ RCBomb::Detonate(): input to state machine
					+ Update():
						+ Basics
						+ Explosion
					+ Finalize GetArea(): decide if new enlarged explosion looks good
					+ NeighborhoodDisturbed()
						+ Equivalent to RCDetonate()
				+ TimerBomb:
					+ Update(): state machine
						+ Sparkles: sort frames by distance on fuse and do random choice on sliding window
						+ Add a base frame of bomb with no fuse
							+ Rename all frames
							+ Fix calculation of base frame count at Update()
						+ Smoke:
							+ 3 sequential frames
					+ NeighborhoodDisturbed()
						+ Explodes only if state machine duration < own time left
			+ Bombs class
				+ Not ElementContainer, just manager
				+ cctor takes shared_ptr<IGameEventHandler>, ExplosionHandler, Points &
				+ Update(OnBombExplosion(position, radius)) -> void
					+ Runs through all bombs and invokes ::Update() on each
					+ Removes a bomb if its Update() returns false
						+ Detach it if attached
				+ ToggleTimer/RCBombAt(position) 
					+ same logic as pinned points
					+ returns boolean
				+ DetonateRCBombs()
					+ Calls Detonate() at each RCBomb
				+ Upload(RenderContext)
					+ Always upload all bombs, each w/current render frame index
				+ OnPointDestroyed(idx)
					+ For each bomb:
						+ If bomb is attached to this point:
							+ Detach bomb from point
						+ If bomb within (new, smaller) radius from point:
							+ Call bomb->NeighborhoodDisturbed()
				+ OnSpringDestroyed(idx)
					+ Bombs also takes Springs
					+ For each bomb:
						+ If bomb within radius (new GameParameters parameter, smaller) from spring mid-point:
							+ Call bomb->NeighborhoodDisturbed()

			+ Points also has bool HasBombAttached buffer for interactions & lookups, just like pinned points 
				+ Also changes mass (just at point, for gravity only...)				
				+ Flag and mass change is done at Points::AttachBomb()/Points::DetachBomb() 

			+ Events:
				+ OnRCBombPlaced/Removed(size, underwater): used by MainFrame to enable/disable detonation menu item
					+ Also invoked when explodes
				+ OnTimerBombPlaced/Removed(size, underwater): used by SoundController to start/stop and set volume
				  of timer bomb sound
					+ Also invoked when explodes
				+ OnBombDetonated(size): used by SoundController 
				+ OnRCBombPing(size): used by SoundController 

			+ Ship implements:
				+ ToggleTimer/RCBombAt(position)
					+ FW to Bombs
				+ DetonateRCBombs()
					+ FW to Bombs
				+ @Update(): invokes Bombs::Update() w/handler
					+ After spring stress check, so explosion is visible before it breaks things up
				+ @Render(): invokes Bombs::Upload(RenderContext)				
				+ Ship::PointDestroyHandler: 
					+ Bombs::OnPointDestroyed(idx)
				+ Ship::SpringDestroyHandler: 
					+ Bombs::OnSpringDestroyed(idx)

			+ RenderContext:
				+ RenderContext:
					+ Load textures
						+ RC bomb
						+ Timer bomb
						+ Make sure textures are sorted by index
							+ First index for multi-frame is 0 in filename as well
					+ Forward calls
				+ ShipRenderContext
					+ Buffers just like pinned points
					+ Render
			+ MainFrame/Tool:
				+ Register for events and process OnRCBombPlaced/Removed() to enable
				  Detonate menu item
				+ Load 2 cursors
					+ Set hotspot
			+ SoundController:
				+ Event handlers

			+ Media:
				+ TimerBomb cursor
				+ RCBomb cursor
				+ TimerBomb textures:
					+ Bases w/different fuse lengths
						+ With fuse burning, separate unlighted frames
					+ Explosion frames
				+ RCBomb textures:
					+ Base
					+ Pings
					+ Center
					+ Explosion frames
				+ Bomb explosion sounds
					+ N1 normal, N2 underwater
				+ RCBomb ping sounds
					+ 1 normal, 1 underwater
				+ TimerBomb fuse sound
					+ 1 fast, 1 slow
				+ Timerbomb defused sound ("sizzle")
				+ Bomb placed sounds
					+ N1 normal, N2 underwater
				+ Bomb removed sounds
					+ N1 normal, N2 underwater

		+ Bomb explosions: see if better done with force fields
			+ At each explosion frame: radial forces, centered at center, strongest at radius=f(expl frame)

		+ 3rd type of bomb: anti-matter bomb
			+ [Do after texture json]
			+ When it explodes: first sucks everything in, then evertyhing out
				+ Controllable also via ultra-violent mode
				+ Uses "ForceFields" (rename of "ToolForces": applied at each iteration of UpdateMechanicalDynamics and then cleared)
				  for suck-in
					+ ForceFields.cpp/h
					+ Move swirl, grab, bomb explosion to this one
			+ Requires ExplosionType argument at Ship::BlastHandler, or new BlastHandler altogether
				+ Or see if easy to move BombBlaster inside bomb (i.e. explosion code is in bomb's state machine)
				+ Or another way
			+ Plan:
				+ Media:
					+ Sound: continuous (3 choir tones)
					+ Sound: implosion_one (FM)
					+ Sound: implosion_two (whirring, up)
					+ Sound: explosion
						+ Choir with delayed repetitions
						+ First choir is mixed with electronic thud
						+ More emphasys on initial explosion
						+ Redo eventually, with long LFO
					+ Texture: armor
						+ Diagonal arms as well?
					+ Texture: ball, empty
					+ Texture: ball, cloud content
					+ Cursor
				+ Texture DB:
					+ Textures.js
					+ New groups in enum
				+ Sound controller:
					+ New additive continuous sound (like fuse) with random choices and volumes for each
					+ Others
				+ Bomb::IPhysicsHandler
					+ Implemented by Ship
					+ Passed to Bombs and stored as GameEventHandler (i.e. *)
					+ Test 2 old bombs
					+ Create force fields
				+ ForceFields
					+ Move DrawTo and Swirl
						+ Test
						+ Clear ToolForce's
					+ Commit
					+ PreImplosion
					+ Implosion
						+ Trim sound and shorten state machine interval to match
						+ Test coriolis - angular F depending on V of point
						+ Test with angular F being stronger when closer to center
						+ Test with mass-independent accelerations (divide forces by mass)
						+ Test with progress moving along 1/(x-a)
						+ Multiplier for ultra-violent mode
						+ Cleanup force field
					+ Explosion
						+ Add to centrifugal

			+ Lower volume of all breaking/stress (passive) sounds
				+ class GameSound : sf::Sound
					+ setVolume
					+ setMasterVolume
					+ setMuted
						+ each sets volume immediately, no checks
					+ Test:
						+ master volume changes only affects currently-playing category
						+ master volume changes affect future sounds
						+ play farewell sound affects currently playing
						+ play farewell sound affects future music
				+ Find another version of volume sum
				+ Then test again break and stress sounds for volumne
				+ Need to mark CurrentlyPlayingSounds as expendable or not			

			+ Animation:
				+ Cloud rotation slows down during pre-implosion, down to a halt					
				+ Then starts slowly again from the other way around, with v=square of progress
				+ Cross of light
			+ Misc:
				+ Can get rid of deletion checks in force fields?
				+ Test fuse's (slow and fast) sounds for new ContinuousSound architecture
				+ Prevent removal if not in containment (i.e. if detonated already)
					+ Bomb::MayBeRemoved()
					+ Test with all 3

	+ Swirl tool
		+ Force applied is r * AngularForce; AngularForce==m*AngularAcceleration
			+ CW; if Shift -> CCW
		+ Cursors
		+ Need own sound - replicate Draw infrastructure and use different drill
	+ Fix power bar room at all cursors
		+ Try: MakeCursors: make non-transparent pixels green or red, multiplying
	+ Saw
		+ Spec:
			+ Deletes springs (and affected triangles) that cross the *path* of the tool
			+ Continuous sound, overwater and underwater, depending on where x,y is
		+ Impl:
			+ Media:
				+ Cursor up and down
				+ Sound
			+ Events:
				+ Need boolean true/false for sawing
			+ Tool:
				+ L-Down: 
					+ prevMousePos = mouse X, Y
					+ Fire event (asking GameController for game event handler)
					+ Set new cursor
				+ L-Up: 
					+ Reset prevMousePos
					+ Fire event (asking GameController for game event handler)
					+ Set new cursor
				+ Move: if l-down:
					+ if has prevMousePos:
						+ GameController->Saw(prevMousePos, current)
					+ prevMousePos = current
			+ Ship:
				+ Do EnumFlags class in EnumFlags.h
					+ Use it 2 X in Springs
				+ Make sure Spring::Destroy only deletes triangles that share one edge with the spring
					= Nuke Point::Breach and do everything instead in Ship's destroy handler, driven off
					  Springs::DestroyOptions
				+ Test whether should fire the Break event even if only springs are deleted 
					+ For points we fire the event in the ship's PointDestroyHandler; if we
					  want to fire now from ship's SpringDestroyHandler, we must be told whether 
					  the spring destruction comes from a point destruction or not: FromPointDestroy vs FromSpringDestroy
					  + If we do this, we can now also remove firing of break from within Springs::UpdateStrains,
					    as the ship's SpringDestroyHandler would be invoked with FromSpringDestroy
				+ Use Geometry::Segment::TestIntersect()
					+ Also add to it GetAngle...
						+ Move from Texture Rotation
					+ Move also AABB to Geometry
			+ SoundController: new continuous sound
				+ Also underwater

	+ Ultra-violent flag: very strong Draw and Swirl forces

	+ Buoyancy redesign:
		+ test with hack what would happen if all non-hull materials were 1/nth of the mass
		+ python script: allow empty cells (skip cols if != index)
			+ Make template more compact
		+ Regenerate template
		+ Re-check bomb weight
		+ Regenerate template
		+ If ok:
			+ Before unhack: fix ships:
				+ Do Masts and investigate mass effect on breakage
				+ Fix Titanic:
					+ Lighter rudder
					+ Also generally Lighter?
					+ Stronger under funnels (make tin stronger?)
					+ Make it break
						+ Study tension based off mass
							+ Solve integral manually
							+ Do tests
						+ Softer again under funnels
					+ Fix mast
					+ Glass breaks immediately
				+ Fix Base III: make it float
					+ Larger base, boat-shaped
					+ See if it's cooler if it floats more (another floating level)
					+ See with thicker columns (make a new one and call it Base II)
				+ Fix default ship: just lighter
				+ Fix cargo ship
					+ Y offset
				+ Fix Carnival - lighter
				+ Fix Krafting - no sudden stress
			+ Rewrite buoyancy code - use WaterMass
			+ Change materials
				+ No Mass but object with:
					+ nominalMass
					+ density
				+ Springs: get mass from points, not from material
				+ Add density = [copy from current hack] 1/6th for hull, 1/(6*10or4)
				+ Material loading: just store mass*density at mass
			+ Redo Materials Template
			+ Watch out for strength: it was (/ mass * 1000)
			+ Fix strength adjust
				+ Fix max, min
					+ Rethink exponential slider: takes also midpoint (1.0 for us) and then it's two exp curves
		+ Add to change list
	+ Fix buoyancy
		+ Maintain trick with which hull points don't feel buoyancy (or else wood hull would never sink)
		+ Adjust gravity force though
		+ See perf (orig was 3.36%)
		+ Cleanup old
		+ Commit

	+ Make collisions with sea floor more dramatic
		+ Bounce velocity with specular vector

	+ Ephemeral Particles:
		+ Spec:
			+ Carve out fixed-size room at tail of Points for ephemeral particles				
				+ Each has own lifetime
			+ Ephemeral particles cannot be deleted
			+ Rendering: via:
				+ ShipRenderContext::UploadEphemeralParticlePoints (e.g. for points)
					+ Just indexes
					+ Color/alpha portion of buffer has to be uploaded first
				+ ShipRenderContext::UploadGenericTexture (e.g. for bubbles)
					+ Need to also support alphaTransparency
			+ Ephemeral particles are drawn with own color, including alpha going to transparent as lifetime increases
				+ Test first perf impact of using vec4f for point colors
					+ If sucks a lot, will need new extra buffer just for points' alpha
						+ Also this buffer is segmented
				+ Ephemeral portion of entire points color buffer needs to be reloaded at each Upload() 
				  or UploadEphemeralParticles() (2*)
					+ Use glSubBufferData
					+ If we go for separate alpha buffer: also do for ephemeral portion of alpha buffer
		+ Impl:
			+ Test vec4f for colors
				+ Points
				+ ShipBuilder
				+ RenderContext/ShipRenderContext
				+ Shaders
			+ Set max eph particles to 1024
			+ Points allocs extra room
				+ Also stores ship point count and start index
			+ Points has new buffers:
				+ EphemeralType (uint8 enum)
					+ None (set at non-ephemeral and at dead ephemerals)
					+ Debris
					+ Sparkle
					+ AirBubble
					+ Smoke
				+ EphemeralStartTime (clock point)
				+ EphemeralMaxLifetime (std::chrono::milliseconds)
				+ private: 
					+ EphemeralState: union of public structs (much like ElectricalElements::ElementState)
						+ Debris: {}
						+ Sparkle: {}
						+ AirBubble: {}
						+ Smoke: {}
					+ Buffer<EphemeralState> mEphemeralStateBuffer;

			+ Ship: limit point range:
				+ @ destroy tool, @ bombs explosions, and @ anything else that destroys point: do not destroy ephemeral points
				+ @ toggle bombs: do not attach to ephemeral points
				+ For all of these: use Points::NonEphemeralPoints iterator, or check EphemeralType != None, depending on the case
						
			+ Points::CreateEphemeralParticleDebris: 
				+ Args:
					+ Position, Velocity
					+ MaxLifetime
					+ Material *
						+ Requires MaterialDatabase to be handy at invoker of CreateEphemeralParticleDebris
							+ Ship must take a DB by value at cctor
						+ Though Debris uses spring's material
				+ Impl:
					+ Find first expired particle; if not found, pick the oldest
						+ Requires mFreeEphemeralParticleSearchStartIndex
						+ In private ElementIndex FindFreeEphemeralParticle()
							+ sets mFreeEphemeralParticleSearchStartIndex
					+ Store Color, Position, Velocity
					+ Store Mass
					+ Do any other initializations that we do at Points::Add(...)
					+ Store MaxLifetime, and zero lifetime
					+ Set mAreEphemeralParticlesDirty = true

			+ Points::UpdateEphemeralParticles(clockNow):
				+ For each point, check lifetime vs max lifetime
				+ If time has expired (now):
					+ No need to mark as deleted to hide them, EphemeralType==None suffices to prevent them from being rendered
					+ Reset velocity and integration factor of expired particles to avoid drifting
						+ Rename Points::Pin/Unpin() to Freeze/Thaw()
					+ Set EphemeralType to None
					+ Set mAreEphemeralParticlesDirty = true
				+ Else: do per-type state machine, with dispatch coded in method depending on type, invoking 
				  per-type state machine method; for example:
					+ Those that are points:
						+ Calc remaining life
						+ Update alpha either in (portion of) color buffer or in (portion of) alpha buffer
					+ Those that are textures:
						+ Calc remaining life

			+ Points::UploadEphemeralParticles():
				+ 1) Upload portion of color buffer/alpha buffer specific to ephemeral particles
				+ 2) If mAreEphemeralParticlesDirty:
					+ RenderContext::EphemeralPointUploadStart()
				+ 3) For all ephemeral points with EphemeralType != None: use dispatch coded in method depending on type, invoking 
				     per-type upload method; for example:
					+ Those that are points:
						+ Add point index to a buffer
					+ Those that are textures:
						+ Call directly ShipRenderContext::UploadGenericTexture(...)
				+ 4) If mAreEphemeralParticlesDirty:
					+ RenderContext::EphemeralPointUploadEnd()
					+ Set mAreEphemeralParticlesDirty = false

			+ Ship::UpdateEphemeralParticles(clockNow):
				+ Calls Points::UpdateEphemeralParticles(clockNow)
				+ Emits ephemeral particles from emitters (e.g. smoke)
					+ For now empty

		+ Cleanup:
			+ See if can control debris generation via GameParameters, which must be made available at 
			  Ship::SpringDestroyHandler

		+ Tests:
			+ Pin ephemeral particle
			+ Many connected components

	+ Do debris each time a spring breaks
		+ Look'n'feel: 
			+ Points of the color of the spring's material
				+ Actually, points of the spring's material
		+ At Ship::SpringDestroyHandler()
			+ Choose 0, 1, or 2 debris // Experiment
			+ For each:
				+ Material = spring's material
				+ Position = midpoint of spring
				+ Velocity = point on circle as:
					+ Radius: random in [1, 5] // Experiment
					+ Angle: random in [0, 2PI]
				+ MaxLifetime = from GameParameters static const, plus random factor in [0.5-1.0]
		+ Debris:
			+ Update: 
				+ Update color's alpha based off remaining lifetime, linear
			+ Upload: 
				+ Just store index in buffer

		+ Test look'n'feel and finalize constants

	+ Ocean depth bitmaps
		+ OceanFloor cctor takes ResourceLoader
		+ ResourceLoader used by ocean floor to load image
		+ OceanFloor translates image into float[] with raw pixel y's
		+ At update, raw pixel y's are normalized/enhanced with new GameParameters constant
		+ Test

	+ Extended status text
		+ Shows:
			+ Current zoom
			+ Rendering vs simulation percentages
				+ GameController continuously updates, same way as FPS
			+ If paused
				+ Actually, this is from StatusText
		+ Multi-row:
			+ Text layer gets it split & gives vector to TextRenderContext
	
	+ Slider for "simulation quality", affecting num of mechanical simulation iterations
		+ Update GameParameters - Points and Springs might have to recalc things on changes
			+ Ship
			+ Points
			+ Springs
		+ Fix: invoke points.updategameparams
		+ SettingsDialog: under mechanics tab
		+ Requires extended status text w/measurements
		+ See what to do with stiffness setting: max 1.0f? Leave it

	+ Fix ephemeral particles
		+ Pass also "now" all over the place
			+ End put back UpdateEphemeralParticles where it was
		+ Just single vector of PointIndex, no connected components
		+ Make ephemeral particles' update based on simulation clock, not wall clock
			+ "now" passed everywhere really has to become a "simulationNow" float
		+ Test
		+ Finalize constants

	+ Do chainsaw sparkles with Ephemeral Particles
		+ At Ship::Chainsaw for each broken spring
		+ Initial particle dynamics:
			+ Position: midpoint of spring
			+ Velocity: radial vector:
				+ Butterfly perpendicular to *direction of sawing*, not spring
				+ Magnitude: uniformly random in range
			+ Number: per Update step: uniform random centered around SparkleDensity (ratio over 10, initially) (from GameParameters, adjustable)
			+ Color:
				+ Metal: brightest red to bright red
				+ Else: base material's render color
			+ Finalize parameters
			+ Final test

+ Water
	+ Water
		+ Ship::LeakWater:
			+ Try rearc: just check if leaking and if externalWaterPressure (0 if above World::WaterHeight) > mWater
		+ Test hull springs/water propagation
			+ Check if also in old program Titanic.png had non-wet hull rudder: YES
			+ Less hull material in Titanic, but maintain strength
			+ Test Titanic afterwards
 	+ Rush sound: should water rush sound be more....rushy?
	+ Water rearc:
		+ Points::Water is height of water column that provides equivalent pressure
			+ When 0<=Water<=1 is also fraction of volume filled with water
			+ Add comments at Points
		+ Ship::LeakWater:
			+ Calc velocity of entering water with Bernoulli
				+ Still need to cap to max (external pressure) because of dt possibly being too large?
			+ Also do negative pressure (i.e. water leaving cell)
		+ Do water-momentum based dynamics					
		+ Cleanups and deferred TODOs:
			+ Test with Bernoulli's spring velocity being added to point's water velocity (times its mass of course)
			+ Do U-shaped tube
			+ SettingsDialog:
				+ Flex spacing
			+ Rename water detail parameter: Water Detail Coarseness
			+ Take perf measurements:
				+ FPS: 26.8/26.9/27.0/27.4
				- MainFrame::RenderGame:	61.08%
				- GameController::Update:	32.92%
					- UpdateWaterDynamics:	 5.85%
						- UpdateWaterVelocities:	5.77%
			+ Refactor UpdateWaterVelocities:
				+ Normalize based off sum of magnitudes
				+ Finalize double-buffering
					+ Take perf measurements afterwards: 27.3/27.5/27.6
				+ 1) Test with memcpy of water buffer
					+ Perf before: UpdateWaterVelocities: 5.59%
					+ Inline first (taking also oldPointWaterBuffer * as restrict)
					+ Perf after: 27.4/27.6
					+ Move to Points as:
						- float * restrict CheckoutWaterBufferTmp()
						- void CommitWaterBufferTmp(float * restrict ...)
							- asserts same as own				
				+ 2) See to improve (sse for 2?) water momentum making/demaking
					+ Move to Points (anyway) as:
						- vec2f * restrict CalculateAndCheckoutWaterMomentumBuffer()
						  or: vec2f * restrict PopulateWaterMomenta()
							- Returns the buffer afterwards
						- void CommitWaterMomentumBuffer(float * restrict ...)
							- asserts same as own
						  or: void PopulateWaterFromMomenta()
				+ Use restrict pointers also for source buffers and springs' properties
					+ Start with only waterBuffer and waterVelocityBuffer, see if improves 1) pre- and post- steps,
					  and 2) main loop
					+ Check asm before
					+ Take perf measurements afterwards: 27.7/28.0
			+ Move "other endpoint" to Springs class
				+ Verify with asm: it's inlined
			+ Finalize 
				+ Take measurements: 27.4/27.7/27.9
				+ Check asm
					+ Momenta initialization
					+ Velocity recalculation
				+ Finalize perf snapshot
			+ ShipRenderContext: add waterLevelOfDetail param to all other shader programs
			+ SettingsDialog: make it tabbed: mechanics, fluid, rendering
			+ Add crazyness to SettingsDialog
			+ Rename GameParameters::GravityNormal to GravityNormalized
			+ GameParameters:
				+ Rename NumDynamicIterations as NumMechanicalDynamicsIterations
				+ Add NumWaterDynamicsIterations
			+ Is Springs::WaterPermeability still used?
			+ See if GameParameters::WaterPressureAdjustment still needed (or needs to change name)
			+ Remove old water dynamics code from Ship
	+ UpdateWaterVelocities: 
		+ See what happens when we also incorporate dest's velocity in Bernoulli
		+ See what happens with drag (after final calculation of velocities)
			+ See if needs to be linear or quadratic
		+ Test with reflected momentum
	+ Splash sound:
		+ First we need to cleanse "rushing water" of bubbles sound
		+ New "splash" continuous sound, with volume controlled by total magnitude of momentum change
			+ Test with ProbePanel, ScalarTimeSeriesControl
			+ Go for kinetic energy lost instead		
		+ Finalization:
			+ Nail down sound
			+ Nail down volume
			+ Measure perf:
				+ FPS: 25.9/26.1/26.2
				+ UpdateWaterVelocities (2m): 11.19%
					+ expf: 2.34%
			+ When removing Q from point, test with using only component of oldV along spring
			+ Recheck one-sided deltaT
			+ Cleanup
			+ Run in debug mode
			+ Averager needs to become member of ship
			+ Optimizations - things to test:
				+ That scalar/vector/scalar
				+ See if can either update all point water momentum once, or for each spring - not both like now!
					+ => FPS=26.2/26.5
					+ UpdateWaterVelocities (2m): 8.75%
						- expf: 0.81%
				+ Low-hanging fruit
				+ Initial point visit for populating exp(water) 
					+ Requires temp buffer
					+ Pre: 26.2/26.5
					+ Post: 26.8/26.9
				+ Initial spring visit for all Bernoulli's (scalar)
					+ Requires temp buffers
					+ Still need to assign sign depending on whether pointIndex is spring's point A or not
					+ Post: 26.8/26.9
					+ NOT WORTH IT
			+ Should replace water rushing in - decide


+ Debug light/drag issue
	+ Could be due to distance too close and shooting light to sky
+ Do connected component detection
	+ Get new baseline
+ See perf of merged LeakWater+DetectConnectedComponents vs Separate
	+ Use perf analyzer:
		+ Merged:
			- Ship::Update: 60.64%
				- PreparePointsForFinalStep: 3.14%
		+ Separate: 
			- Ship::Update: 63.69%
				- LeakWater: 0.11%
				- DetectConnectedComponents: 3.02%
+ Fix multiple clouds

+ Game interactions:
	+ IGameEventHandler: individual methods, including parameter changes, all default-implemented
		+ OnDestroy(Material const *, size) // size=1 for each destroy, but Dispatcher aggregates assuming size=anything
		+ OnBreak(Material const *, size) // size=1 for each break, but Dispatcher aggregates assuming size=anything
	+ GameController::RegisterGameEventHandler(IGameEventHandler *)
		+ calls into GameEventDispatcher::RegisterGameEventHandler, who does:
			+ Registration of real sinks (vector of plain IGameEventHandler *)
			+ Aggregation of duplicate events 
				+ e.g.: OnBreak: keep distinct Material * and sum for size
				+ Clears aggregations at OnStepStart() (from GameController) and publishes them
				  to registered sinks at OnStepEnd()
	+ GameController gives shared_ptr<GameEventDispatcher> to Game at Game's cctor (as shared_ptr<IGameEventHandler>)
	+ GameController calls mGameDispatcher (shared_ptr<GameEventDispatcher>)->OnStepStart()/End()
	+ Invoke events at Game and below (pass handler at XYZ.Update())
	+ First GameEventHandler: EventTicker
		+ It's custom panel at bottom with text ticker
		+ EventTicker holds wxPanel and draws it (figure out OnPaint and DC...)
		+ Created by MainFrame and registered by MainFrame on GameController
		+ Hide it by default and only show via MainFrame menu option
		+ Complete event handlers
		+ Do ship sinking event notify in ship (mWater > 1/3 points)
	+ Increase max grab force

+ Sound:
	+ SFML:
		+ Build own
		+ Add bins reference to ship CMake
	+ Mute @ Menu
	+ Fix splash progress - make sure final "Complete" shows
	+ Break/Destroy: handlers also take bool isUnderwater (based off Y of broken thing wrt world's water height)
	+ MainFrame initializes SoundController, which implements IGameEventHandler
		+ Initializes off visit of Data/Sounds and Data/Music, w/Music and Sounds
			+ Mapping of sounds with IGameEventHandler events via:
				+ Material::optional<SoundProperties>
					+ SoundMaterial: enum(wood, metal, ...)
					+ Material enums have StrToX()
				+ Filename patterns of sounds and music (e.g. destroy_wood_small_underwater_1.wav)
					+ Parse: if 'destroy'=>expect SoundMaterial next, then ...
				+ Storage of sounds:
					+ Maps store vector<SoundBuffer>
						+ Values are all the variations of the sounds, and 
						  SoundController chooses randomly
					+ Sounds are created when played and stored in queue together with timestamp
				+ Sounds stored in maps (of maps of...) indexed by coordinates off filename patterns
					+ Material's enums used as coordinates, together with SoundController's own
					  enums (e.g. action, size, underwater type)
				+ ResourceLoader has: 
					+ GetSoundFilenames() -> all sound (relative) filenames
					+ GetSoundFilepath(filename)
		+ Do random choice
		+ Need to manage number of currently-playing sounds
			+ When currently playing > MaxPlayingSounds (constexpr):
				+ ScavengeCompletedSounds()
				+ If still full, stop oldest (among same SoundType, or absolute if none) and pop it 
			+ ScavengeCompletedSounds() also called at SoundController::Update()
	+ Stress event
		+ At break loop: for each spring:
			+ Spring->UpdateTensionStrain(..., IGameEventHandler):
				+ If is broken=> this->Destroy(); break event (calc undewater); 
				+ else if is stressed=>
					+ If !mIsStressed:
						+ set; stress event (calc undewater)
				+ else:
					+ mIsStressed = false;
		+ Spring::IsStressed()->mIsStressed, used for rendering
	+ Don't play soundbuffer if already playing for < 20ms
	+ Sounds:
		+ destroy, stress
		+ finish destroy 
		+ better cable snap
		+ Listen to all materials
		+ fix destroy cable/string's
		+ Batch convert all to flac
			+ Test and commit
		+ underwater: with reverb effect
			+ Batch mode, save aside current underwater's first!
	+ MainFrame registers SoundController as Handler with GameController
	+ Sinking music
		+ GameController starts it upon OnStartedSinking() event
	+ See if sounds should be spaced more apart
	+ See underwater cable sounds - sound like metal?
		+ break small 1, 3, 4
		+ destroy medium 1
		+ destroy small 4
	+ Draw event: 
		+ GameController fires Grab, simple
		+ SoundController: uses own sound.isPlaying as state and starts @ event/stops @ update
			+ Uses two consecutive Update() w/no Draw in-between as stop
			+ how to loop though?
	+ Rethink notification of Draw and Swirl events
		+ Remove from GameController, fire at tool via "Toggled(bool)" events
		+ Remove magic from SoundController
		+ Can always modulate sounds at Tool::Update, for example asking GameController::IsUnderwater(screen coords)
			+ Do at Chainsaw, do underwater sound 
				+ Change event handler:
					+ OnSaw(opt<bool> isUnderwater): off, on overwater, on underwater
		+ Test: get rid of all FlushEvents outside of update
			+ If OK, remove commented-out code
	+ Reset sound controller at ResetAndLoadShip()
	+ Water rushing-in
		+ Continuously-playing sound
			+ Find sample
		+ Volume time-interpolated off total quantity of water that entered ships during step
			+ Communicated via new event - OnWaterRushedIn(total_water_quantity)
			+ total_water_quantity update (passed by arg &) replaces mTotalWater update
				+ mTotalWater updated afterwards with +
			+ Volume = 100 * ( -1/(Qw+1) + 1 )
				+ Qw = some scaled version of total_water_quantity (1.0f might suffice)
	+ Separate sound control for tools
	+ Saw sound
	+ Turning down a bit the very high pitch stress noise
		+ Do it on flac - on all high-pitched ones (same amplitude)
	+ Sawing: do not publish destroy events when cutting springs, but new "Sawed" events with own metal/wood sounds
		+ Two new continuous sounds: metal and wood saw
		+ OnSawed is invoked with Type and size - size=0 means nothing
		+ Event handler sets continuous sound's volume up/down (when size=0), and eventually starts it
		+ Stopping continuous saw sound also sets volume of these two to zero

+ Put credits
	+ Splash: https://www.artstation.com/stukata/profile, contact the guy

+ Fix: When land is above water, water is upside down

+ Optimization: to improve locality: points in contiguous buffer
	+ No PointerVector but (fixed) std::vector<Point>, and others point to locations in the vector
	+ Points never deleted, just marked
		+ So have to check point.IsDeleted() each time the Point buffer is iterated
		+ No check
	+ Point destroy: also clear *own* references
	+ Try contiguous buffer also with springs and triangles
		+ And not checking isDeleted
			+ Remove assert's
		+ Multi-step create loop
		+ Spring destroy: also clear *own* references
		+ Triangle destroy: also clear *own* references
		+ Do check IsDeleted for Spring and Triangle operations that may affect connected non-deleted points
		+ New perf: 15.7/15.8
		+ See ElementContainer::range(start, end)
			+ UnitTests, verify last excluded
	+ IsDeleted needs only be checked at SpringRender and TriangleRender
	+ Try fast_qrt for vec2f::length()
	+ Test fast_XYZ at vector
		+ fast_inv_sqrt: 15.2/15.3/15.3
		+ 1/sqrt: 15.3/15.3/15.3
		+ Nuke'em if ok
	+ EventTickerPanel is stealing 1.99% even when not shown

+ Render optimization: only upload spring elements, triangle elements when they're dirty (deletion occurred)
	+ Get perf analysis first:
		- Game::Render: 34.90%:     Ship::Render: 31.53% (Incl)	3.05% (Excl)
			- RenderShipEnd: 28.24%	- Ship::RegisterDeletion: sets mAreSprings/TrianglesDirty=true
	+ cctor: true
	+ set to false after uploaded to RenderContext 
	+ Move XRay flag consumption to RenderContext 

+ Now that we have connected components, fix covering of ship pieces:
	+ Draw batches of triangles and springs by component, so that pieces are "covered" nicely
		+ Ship keeps track of # of connected components and of each size
		+ At RenderXYZ(), allocate N buffers for the vertex indices and dispatch each triangle/spring
		  to the correct buffer based off ConnectedComponentID 
			+ ConnectedComponentID passed by caller (spring or triangle) based off the (first) point
			  of the primitive
				+ assert other points have same ID
			+ Note: points themselves are not affected by this; they're still uploaded in their entirety 
			  once per cycle
		+ At RenderXYZEnd(), draw each connected component buffer from last to first
		+ Do for triangles
		+ Do for springs
		+ Each connected component must be drawn together - its springs then its triangles

+ Technical Debt:
	+ Resources: lowercase filenames
		+ git
		+ code
	+ /Data
	+ /Ships
		+ Uppercase ship filenames
		+ Code (ResourceLoader)
		+ source (git)
		+ CMake
	+ MainFrame::Die(msg of exc)
	+ Get rid of Game.cpp and move functionality to GameController
		+ ResourceLoader::LoadDefaultShip()
		+ Also, don't load default ship autonomously (need to register event handlers before that happens);
		  rely on MainFrame calling GameController::LoadDefaultShip() after registration
	+ Change calls to Point::SubtractFromLastPosition() to AddToLastPosition() and use (& implement) unary '-' operator for vectors
	+ Points and Springs and Triangles::Destroy()'s are templated on Point/Spring/Triangle"Being"DeletedHandlers (others than self),
	  & ship passes own methods
		+ OR: even better, as handler never really changes: cctor takes handler at beginning, given by ship,
		  and stores as std::function
		+ Handlers invoked *before* actual deletion
			+ Comment on handlers on connected-to-argument might be deleted
		+ Not re-entrant - can't delete from within
		+ Handling of pinned point deletion is then done here
		+ See if also whole logic of point<->spring<->triangle can be done in handler
			+ If so, don't pass containers at various Destroy()'s
		+ Test
	+ CircularList::Erase unit test: complete verification of returned iterator
	+ Containers::Destroy and GameEventHandler::OnDestroy rearc:
		+ 3 containers are given shared_ptr<GameEventHandler> and ParentWorld & at cctor
		+ The 2 Destroy()'s fire events (after invoking DestroyHandler), unless otherwise specified
		  via DestroyOptions
		+ Ship's DestroyHandlers don't fire events anymore, and Ship::SpringDestroyHandler takes boolean
		  for triangles (translated from Springs::DetroyOptions)
		+ Test assert's with Debug build
	+ Move definition of ElementIndex et al into GameTypes.h
	+ Move also pinned points to a PinnedPoints class, just like Bombs
	+ Textures are json files, with world size, offset, and lighting boolean
		+ SEE MOLESKINE
		+ Cleanup:
			+ RenderContext:
				+ Hook up IProgress to individual loads
					+ Double-check total count adjustment				
			+ Commit
		+ Then:
			+ (Ship)RenderContext: Do not store sizes but whole database instead
				+ Database must be associated with GLuint's of textures
				+ RenderContext stores (moves) database at cctor
				+ Passes reference to ship
				+ TextureDatabase::GetFrameMetadata(TextureFrameId)
					+ TextureDatabase builds map of references at cctor
			+ Remove hardcoded sizes and offsets and substitute with metadata lookups
				+ Cloud size
				+ Water size
				+ Land size
				+ Pinned point size
				+ Bombs sizes and offsets
			+ Test
				+ Double-check clouds's aspect ratio
				+ Anchor at all frames of timer bomb
			+ Commit
			+ ShipRenderContext: replace pinned points and bombs with Upload(Ship)TextureRenderSpecification:
				+ PinnedPoints
				+ Bombs:
					+ Upload4Render() eventually invokes twice (lighted and unlighted)
					+ Frame indices are TextureFrameIndex instead of uint32
				+ Args:
					+ ShipID (used only by RenderContext to dispatch)
					+ ConnectedComponentID
						+ Until Z-rearc: ShipRenderContext has one TextureRenderSpecification per-connected component
						- After Z-rearc: put in buffer for shader to transform to Z
					+ Position (vec2f)
						+ Of anchor
					+ Orientation (std::optional<vec2f, vec2f>)
					+ TextureFrameId
				+ ShipRenderContext gets TexturePolygon from TextureRenderManager::CalculateTexturePolygon
					+ TexturePolygon is declared at RenderTexture.h, which includes other Texture render .h's
					+ Contains 4X{pos,textureCoord, and AmbientLight adjustment}
					+ For the time being it calculates also rotation
					+ Nuke RotatedTextureRenderInfo.h
				+ Use a single shader for these "simple" textures
					+ Takes TexturePolygon, described to OpenGL
				+ ShipRenderContext rearc:
					+ Textures -> TBD Name="Generic"
					+ Simplify alpha and beta with just beta, and beta is "ambientLightSensitivity"
				+ ShipRenderContext: Detach textures from ConnectedComponentData
					+ RenderContext::RenderShipStart(connected components)
					+ RenderContext::RenderShipEnd()
				+ Double-check cloud rectangle calc'n against TexturePolygon
				+ Test
					+ Double-check clouds's aspect ratio
					+ Anchor at all frames of timer bomb
					+ Rotation of bombs
				+ Move TextureRenderManager::AddRenderPolygon method to .h, and call it EmitRenderPolygon
				+ Move bind into TextureRenderManager, templated
				+ Nuke old bombs/pinnedpoints at ShipRenderContext
				+ Commit
		+ Change the single shader to do *all the work* (for the "simple" textures, including rotation) for all ships and connected components
			+ Initially, runs on 1 texture at a time
				+ After atlas and Z, runs on all textures (via atlas' per-frame texture coordinates)
			+ Perf before moving rotation into shader (2000 textures, @ 30s):
				+ With multiple batches:
					+ FPS: 16.5
					+ ShipRenderContext::RenderGenericTextures: 31.29% 
					+ TextureRenderManager::EmitRenderPolygon: 0.53%
						+ atan2f: 0.16%
						+ sin+cos: 0.09%
				+ With single batch:
					+ FPS: 12.24
					+ ShipRenderContext::RenderGenericTextures: 4.65%
					+ TextureRenderManager::EmitRenderPolygon: 0.83%
						+ atan2f: 0.28%
						+ sin+cos: 0.16%
			+ Move rotation et al into shader (without Z for now)
				+ TexturePolygon is modified to also contain orientation
			+ Perf after moving rotation into shader:
				+ With multiple batches:
					+ FPS: 16.4
					+ ShipRenderContext::RenderGenericTextures: 32.23% 
					+ ShipRenderContext::UploadGenericTexture...: 0.56%
						- atan2f: 0.14%
						- vector: 0.10%
				+ With single batch:
					+ FPS: 12.29
					+ ShipRenderContext::RenderGenericTextures: 6.88%
					+ ShipRenderContext::UploadGenericTexture...: 0.75%
						- atan2f: 0.21%
						- vector: 0.08%
			+ If OK:
				+ Nuke TextureRenderManager::EmitRenderPolygon and do all at ShipRenderContext::UploadGenericTextureRenderSpecification
				+ Move TextureRenderPolygonVertex out of RenderCore and make it private to ShipRenderContext

			+ Extra optimizations to test:
				+ vector (no test)
				+ Use a vec4 for the four lonely floats
					+ With multiple batches:
						+ FPS: 16.4
					+ With single batch:
						+ FPS: 12.29
				+ further packing: two vec2 as one vec4
					+ With multiple batches:
						+ FPS: 16.4
				+ Commit
				+ atan in shader - REJECTED
					+ requires two extra vec2 or a vec4
					+ With multiple batches:
						+ FPS: 16.2
						+ ShipRenderContext::RenderGenericTextures: 31.50% 
						+ ShipRenderContext::UploadGenericTexture...: 0.56%
							+ vector: 0.56%
			+ Final perf test:
				+ FPS: 16.4
			+ Text single texture rotating
			+ Cleanup:
				+ Ship's test upload
				+ reorder RenderCore::VertexAttributes
			+ Final test with game, real textures
	+ Fix issue with very fast rope sinking
		+ How's a wet rope different than iron hull? Test with test_ship.png
		+ It's because ropes get water (when broken) and gravity force is based off point_mass+water, while integration only uses point_mass
			+ In fact it also applies to all light hulls that are broken
		+ See if can apply buoyancy always, and thus get rid of Points::Buoyancy
			+ Nope: too many hull materials would float
		+ NOPE: Apply water mass at Integrate then? And what about springs - should use new mass there as well?
		+ Two possible fixes:
			+ Just don't consider water at gravity if buoyancy=0 (i.e. if hull)
				- i.e. revert the buoyancy fix
				- result is that wet hull points never feel water weight (and neither buoyancy)
			+ THIS ONE: Or, buoyancy=0 points (i.e. hull points) never take water, period
				+ i.e. they are never set leaking upon spring destruction
				+ First figure out how internal hull gets wet - if it does - IT DOES NOT!


	+ Move RenderContext et al into Render:: namespace and file group
			+ See if TextureTypes.h is still needed and whether it can be moved to GameTypes
				+ After all, ShipRenderMode is in GameTypes
				+ Polygon for now moves to that class that makes it

	+ ToolController rearc:
		+ ToolController has pointer to SoundController, and tells the latter when to play and stop tools' sounds 
		+ IGameEventHandler events then exist only for the world-generated noises (e.g. something really breaking), not
		  for the tools
		  + So Swirl, for example, should disappear from IGameEventHandler; some others as well
		  + Tools don't invoke IGameEventHandler->OnSwirl(), for example
		  + Removed:
			+ OnSaw
			+ OnDraw
			+ OnSwirl

	+ CMake:
		+ INSTALL target for release
		+ RelWithDebInfo: Inline any suitable (/Ob2)

	+ Replace ShipDefinitionFile's metadata with ShipDefinition

+ Ships:
	+ Titanic:
		+ Introduce weak metal
			+ Use it underneath funnels

+ Help:
	+ wxWidgets HTML help: http://docs.wxwidgets.org/3.0/group__group__class__help.html
		+ Also, just https://github.com/wxWidgets/wxWidgets/blob/WX_3_0_BRANCH/samples/html/about/about.cpp
	+ Use icons for keys

+ Fix bug: when you reload ship when paused, no clouds & no ship are visible until resumed
	+ World::Initialize():
		+ Calcs connected components for each ship
		+ Builds clouds
		+ Invoked by GameController after pair of world::Reset and world::AddShip()

+ Compare old (released) look with this one, and see if there are changes (in phys, render,...) to take in
	+ Also jellyfish fixed in 1.2.6? NO

+ Release:
	+ Do structure first (above)
	+ Check if less rope mass makes empress of britain not break
	+ Add all other ships 
		+ Remember: uppercase and spaces filenames
	+ Do new .shp's:
		+ Carnival
		+ Titanic
	+ Rerun perf profiling
	+ Lower volume of stress sounds, so that break sounds are louder
	+ @Release only: make Krafting.shp the default ship
	+ Screenshots @ github readme
	+ Tell art guy
	+ Send email to Luke
	1.3.0:
	+ Fix Ocean Depth
		+ Affects only textures, not land
	+ Make some ships
		+ Copy three balls
		+ Make ShipTools, -quantize verb
		+ Make some stiffer columns of steel, iron, titanium, etc.
			+ materials: also order rows based on mass
			+ Do last steel column stiff
			+ Iron and Wood
				+ Switch stiff wood with new one
					+ Switch also Titanic
						+ Test
			+ Add "f=..." to template or better "M:S:F"
			+ Test newest ship
		+ Copy, change, and fix from old:
			+ Ship5
			+ Ship6
		+ Cruise vessel
			+ Plan:
				1 + New layer, with thin hull and light interior
					+ Fix buoyancy
				2 + Introduce heavy metals - own row, just grey's
					+ Make strong structural beams
				3 + Adjust colors by peeking at lower layer
					+ Redo the layer with quantize
				4 + Detachable life raft 
					+ Make "Nails" material
	+ Call .shp parts ".png.dat"
		+ Rename via git
		+ Edit .shp files
	+ Build and release 1.2.0
	+ Post to forum
	+ Add to gamejolt

+ Lights
	+ need Optional()
	+ Material:
		+ use picojson
		+ Material.ElectricalProperties (optional)
			+ type (Material::ElectricalProperties::ElectricalElementType=lamp, cable, generator)
			+ flat list of all electrical properties, some apply some don't
	+ class Lamp()
		+ points to Point and Point points optionally to ElectricalElement (base abstract of Lamp, Cable, Generator)
			+ ElectricalElement::GetType(){return mType;}: non-virtual, it's optimized by compiler
	+ Move electrical components to ElectricalElements class, an ElementContainer but also like bombs, with update and state machines
	  (but no render)
		+ GameEventHandler and points members
		+ Buffers (type, connected electrical elements, etc.)
		+ AddCable/Lamp/...()		
		+ Destroy
			+ Removes self from connected
				+ OR NOT: If Ship::PointDestroyHandler deletes point's connected springs before point's electrical element,
				  then we can assert that electrical element has no connected points anymore already
		+ Getters ("subset" section) for Lamps and Generators
		+ Update()
			+ Invoked by Ship
			+ For each lamp: runs its state machine 
				+ Via RunLampStateMachine(LampState &)
				+ Outcome: AvailableCurrent
	+ Materials: self-powered lamp
		+ Just boolean property in JSON
			+ Current light material is self-powered
			+ New light material is not
		+ ElectricalElements: store boolean at LampState (const, passed via cctor)
	+ Point has ElectricalElementIndex (or None), passed at cctor
	+ ShipBuilder:
		+ Create ElectricalElements via ElectricalElements::Add
		+ Give point/elec element index to each other
		+ Add connected electrical elements to each other
			+ See how it's done for points, springs, etc.
	+ Nuke ElectricalElement, Cable, Generator, Lamp
	+ Nuke unused Material electrical properties
	+ Ship::PointDestroyHandler:
		+ Destroy point's ElectricalElement, if any
		+ Do this after deleting springs, so that ElectricalElement::Destroy does not have to remove self from connected elements (see above)
	+ Ship::SpringDestroyHandler:
		+ Remove each endpoint's ElectricalElement (if any - both must be elec elems) from each other's ElectricalElement
	+ Move StrToDuration and includes to GameTypes.cpp
	+ Move ElectricalElementIndex at Points to own buffer
	+ @Ship::Update():
		+ New "inline" electrical section:
			+ UpdateCurrentConnectivity():
				+ Invoke regardless of dirty elements, as generators might become wet
				+ From generators to all reachable points, just propagates visit seq num
			+ ElectricalElements::Update()
			+ DiffuseLight()
				+ For each ElectricalElement::Lamp: 
					+ Use its AvailableCurrent and set mLight 
	+ Implement full lamp state machine @ ElectricalElements::RunLampStateMachine
		+ EventHandler: OnLightFlicker(size, length, isUnderwater)
		+ Update() takes Points (for underwater)
		+ Implement
		+ SoundController
			+ Add new sound for electrical cable
				+ 2 X random, X 2 underwater
			+ Find 2 sounds ("electrical discharge" or "electric arc")
				+ And make them also underwater
				+ Lower volume of overwater ones
	+ Optimizations:		
		+ Take perf analysis of circuit test 1 (2 mins Circuit Test 1)
			- World::Update: 30.15%
				- UpdateElectricalConn: 0.06%
					- Deque::new: 0.01%
					- Deque::~: 0.01%
				- ElectricalElements::Update: 0.05%
				- DiffuseLight: 0.43%
		+ Ship::DiffuseLight: see inverting nested loops (for each lamp: for each point)
			+ Need test ship with many more lamps
			+ Before perf analysis: DiffuseLight: 35.83% == ~30,000 samples; fps=22.10
			+ Switch loops:
				+ Requires first point light zeroing!
				+ After perf analysis: DiffuseLight: 30.63%; fps=24.x
		+ Do perf analysis with complex graph
			+ Need circuit test 3
			+ Impact negligible: Ship::UpdateElectricalConnectivity: 0.21%

	+ Diffusion:
		+ Can test it by itself, by using light material and by cheating with current!
		+ After current propagation:
			+ Zero out mLight of each point (use generation sequence number? useful for other Point properties?)
				+ No, easier and probably faster to do it in same pass as LeakWater - LeakWaterAndZeroLight()
		+ Diffusion: propagate mLight to adjacent points (incl. other lamps),
		  inv. proportional to distance^2, with a graph flood stopping at max distance
		+ Point.GetColour() takes also into account mLight (from itself, not from lamp) 
                  and makes alpha blend just like water
		+ Need "off" color to use at lamp point when Lamp is off (different than structural color),
		  used when rendering point in springs/triangles/points
			+ Not used when using textures, of course
			+ Needs material's Color to split in StructuralColor and RenderColor (set to the same except for lamps)
	+ Diffusion improvement: see if can simply add light (rather than max'ing it)
		+ Need to ensure sum is always < 1.0
		+ Or just set to max(1.0, cur+new)
			+ Best when done in point->lamp loop: add up in inner loop, then assign to point as max
			+ Doesn't improve look considerably, and still requires an if

+ Bugs: 
	+ Ship::Render: when there are no changes to elements and we keep uploading stressed springs, we don't reset the count
	  in ShipRenderContext::mElementBufferSizes
		+ Fix simply by having Start and End for uploading stressed springs
		+ Done in FB branch
	+ No default args @ vec cctors
		+ Done in FB branch
	+ Fix mem leak
		+ Plan:
			+ Calc base rate of growth: 500K/sec
			+ Comment out ShipRenderContext::Render halves until find the one
				+ When nothing done in loop: 159K max
				+ Just PinnedPoints: grows fast
				+ No texture & no buffer: grows fast
				+ No parameters: grows extremely slow
				! No OrthoMatrix param, Yes AmbientLight param: grows fast
				+ Yes OrthoMatrix param, No AmbientLight param: grows extremely slow
			+ Undo all (dbl-check)
			+ Commit other work
			+ glHint(..._HINT) x 2 at Render::Start()
		+ Cut down on calls to glSetParameter:
			+ Before FPS: 27.4
			+ ShipRenderContext::SetXYZ (ortho, visible world coordinates, and light)
				+ Sets into all programs
				+ Nuke member references
			+ ShipRenderContext::cctor:
				+ Sets into all programs with value from cctor args (this time by val)
			+ RenderContext::UpdateXYZ
				+ Set into all ships
				+ Passes current values by val into new ships
			+ After FPS: 27.4
			+ Verify leak is slower
			+ Do also at RenderContext
	+ Fix issue with clouds and canvas size (wrong aspect ratio)
	
+ Roadmap:
	+ 1.7.0
		+ Magic spring optimization (*)
			+ Then decide whether to increase the number of basis iterations, and whether to adjust strength
				+ SQ: 2.0 => Basis = 24
				+ Strength to maintain Titanic auto-break: <= 0.397928
					+ Change max strength to 10 and see again value: 0.403352
				+ Tune bombs
				+ See pin				
				+ Change ocean floor bump - remove center chasm and move it right
				+ Fix sound quantity
				+ Adjust volume of those two high-pitched sounds
				+ Adjust container ship
				+ Bomb blast radius: 2.0
				+ Fix missing RC bomb pings 
					+ verify break & stress sounds are still good
		+ Test collisions with seafloor being less destructive
		+ Fix crash
			+ Springs and Triangles cctors: pass default-ccted FixedSizeBuffer() there, not {}
			+ Then revert floor collision
			+ Remove TODO's with checks at: 
				- Ship.cpp
			+ Clear super/sub buffers in destroy handlers

		+ Move inertia & ultra-violent mode
		+ Move tool extension: rotate
			+ Shift: up ccw, down cw
				+ Make it relative to prev pos
			+ Change icon
		+ Slider for water drag adjust
			+ Test with water drag depending on v^2
		+ Update help:
			+ Anti-Matter bombs
			+ Move tool

		+ See collisions' bug
			+ Move tools always update velocity
				+ Checl L'n'F'

		+ Strength adjust at 1.0

		+ Decide max water drag: 
			+ 100: OK,but not really "draggy"
			+ 10,000: awesome

		+ Extended status: take stats from RenderContext
			+ RenderContext::Stats:
				+ LastRenderedShipSprings
				+ LastRenderedShipTriangles
				+ LastRenderedGenericTextureTriangles
				+ LastRenderedConnectedComponents
				----
				+ Reset stats at each RenderContext::RenderStart()

		+ Redo full perf analysis

		+ Recheck L'n'F' for current collision handling
		+ Recheck L'n'F' for strength
